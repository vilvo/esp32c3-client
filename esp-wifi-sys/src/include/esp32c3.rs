/* automatically generated by rust-bindgen 0.59.2 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const SOC_COEX_HW_PTI: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _WANT_USE_LONG_TIME_T: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const CONFIG_SOC_ADC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GDMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_XT_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const CONFIG_SOC_EFUSE_HAS_EFUSE_RST_BUG: u32 = 1;
pub const CONFIG_SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPSPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_HMAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMPROT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BOD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_AES_GDMA: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_ARBITER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_MAX_CHANNEL_NUM: u32 = 5;
pub const CONFIG_SOC_ADC_ATTEN_NUM: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 1;
pub const CONFIG_SOC_ADC_PATT_LEN_MAX: u32 = 8;
pub const CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_RESULT_BYTES: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const CONFIG_SOC_ADC_RTC_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_APB_BACKUP_DMA: u32 = 1;
pub const CONFIG_SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHARED_IDCACHE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_MEMORY_IBANK_SIZE: u32 = 16384;
pub const CONFIG_SOC_CPU_CORES_NUM: u32 = 1;
pub const CONFIG_SOC_CPU_INTR_NUM: u32 = 32;
pub const CONFIG_SOC_CPU_HAS_FLEXIBLE_INTC: u32 = 1;
pub const CONFIG_SOC_CPU_BREAKPOINTS_NUM: u32 = 8;
pub const CONFIG_SOC_CPU_WATCHPOINTS_NUM: u32 = 8;
pub const CONFIG_SOC_CPU_WATCHPOINT_SIZE: u32 = 2147483648;
pub const CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN: u32 = 3072;
pub const CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH: u32 = 16;
pub const CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US: u32 = 1100;
pub const CONFIG_SOC_GDMA_GROUPS: u32 = 1;
pub const CONFIG_SOC_GDMA_PAIRS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_GDMA_TX_RX_SHARE_INTERRUPT: u32 = 1;
pub const CONFIG_SOC_GPIO_PORT: u32 = 1;
pub const CONFIG_SOC_GPIO_PIN_COUNT: u32 = 22;
pub const CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER: u32 = 1;
pub const CONFIG_SOC_GPIO_FILTER_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP: u32 = 1;
pub const CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_VALID_GPIO_MASK: u32 = 0;
pub const CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u32 = 4194240;
pub const CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_PERIPH_ALWAYS_ENABLE: u32 = 1;
pub const CONFIG_SOC_I2C_NUM: u32 = 1;
pub const CONFIG_SOC_I2C_FIFO_LEN: u32 = 32;
pub const CONFIG_SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_RTC: u32 = 1;
pub const CONFIG_SOC_I2S_NUM: u32 = 1;
pub const CONFIG_SOC_I2S_HW_VERSION_2: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_XTAL: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PCM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const CONFIG_SOC_I2S_PDM_MAX_TX_LINES: u32 = 2;
pub const CONFIG_SOC_I2S_SUPPORTS_TDM: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_CHANNEL_NUM: u32 = 6;
pub const CONFIG_SOC_LEDC_TIMER_BIT_WIDTH: u32 = 14;
pub const CONFIG_SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 1;
pub const CONFIG_SOC_MMU_PERIPH_NUM: u32 = 1;
pub const CONFIG_SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const CONFIG_SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const CONFIG_SOC_RMT_GROUPS: u32 = 1;
pub const CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_RMT_CHANNELS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 48;
pub const CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RC_FAST: u32 = 1;
pub const CONFIG_SOC_RTC_CNTL_CPU_PD_DMA_BUS_WIDTH: u32 = 128;
pub const CONFIG_SOC_RTC_CNTL_CPU_PD_REG_FILE_NUM: u32 = 108;
pub const CONFIG_SOC_RTCIO_PIN_COUNT: u32 = 0;
pub const CONFIG_SOC_RSA_MAX_BIT_LEN: u32 = 3072;
pub const CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const CONFIG_SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const CONFIG_SOC_SHA_GDMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const CONFIG_SOC_SDM_GROUPS: u32 = 1;
pub const CONFIG_SOC_SDM_CHANNELS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_SDM_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const CONFIG_SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_APB: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_XTAL: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT: u32 = 1;
pub const CONFIG_SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_SPI_MAX_PRE_DIVIDER: u32 = 16;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_IDLE_INTR: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CHECK_SUS: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_WRAP: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_26M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_COUNTER_NUM: u32 = 2;
pub const CONFIG_SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 20;
pub const CONFIG_SOC_SYSTIMER_FIXED_DIVIDER: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_INT_LEVEL: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUPS: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 54;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 2;
pub const CONFIG_SOC_TWAI_CONTROLLER_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TWAI_BRP_MIN: u32 = 2;
pub const CONFIG_SOC_TWAI_BRP_MAX: u32 = 16384;
pub const CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_PAD_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_USB_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT: u32 = 1;
pub const CONFIG_SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_ICACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 32;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const CONFIG_SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE: u32 = 16;
pub const CONFIG_SOC_MEMPROT_MEM_ALIGN_SIZE: u32 = 512;
pub const CONFIG_SOC_UART_NUM: u32 = 2;
pub const CONFIG_SOC_UART_FIFO_LEN: u32 = 128;
pub const CONFIG_SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const CONFIG_SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_RTC_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_XTAL_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const CONFIG_SOC_UART_REQUIRE_CORE_RESET: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND: u32 = 1;
pub const CONFIG_SOC_COEX_HW_PTI: u32 = 1;
pub const CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 21;
pub const CONFIG_SOC_MAC_BB_PD_MEM_SIZE: u32 = 192;
pub const CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_BT_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_CPU_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_BT_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_MAC_BB_PD: u32 = 1;
pub const CONFIG_SOC_PM_CPU_RETENTION_BY_RTCCNTL: u32 = 1;
pub const CONFIG_SOC_PM_MODEM_RETENTION_BY_BACKUPDMA: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_D256_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const CONFIG_SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_WIFI_HW_TSF: u32 = 1;
pub const CONFIG_SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_GCMP_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW: u32 = 1;
pub const CONFIG_SOC_BLE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_50_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLUFI_SUPPORTED: u32 = 1;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH_RISCV: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH: &[u8; 6usize] = b"riscv\0";
pub const CONFIG_IDF_TARGET: &[u8; 8usize] = b"esp32c3\0";
pub const CONFIG_IDF_TARGET_ESP32C3: u32 = 1;
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 5;
pub const CONFIG_APP_BUILD_TYPE_APP_2NDBOOT: u32 = 1;
pub const CONFIG_APP_BUILD_GENERATE_BINARIES: u32 = 1;
pub const CONFIG_APP_BUILD_BOOTLOADER: u32 = 1;
pub const CONFIG_APP_BUILD_USE_FLASH_SECTIONS: u32 = 1;
pub const CONFIG_BOOTLOADER_OFFSET_IN_FLASH: u32 = 0;
pub const CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_BOOTLOADER_RESERVE_RTC_SIZE: u32 = 0;
pub const CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_PREFERRED: u32 = 1;
pub const CONFIG_SECURE_ROM_DL_MODE_ENABLED: u32 = 1;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_APP_RETRIEVE_LEN_ELF_SHA: u32 = 16;
pub const CONFIG_ESP_ROM_HAS_CRC_LE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_CRC_BE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_MZ_CRC32: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_JPEG_DECODE: u32 = 1;
pub const CONFIG_ESP_ROM_UART_CLK_IS_XTAL: u32 = 1;
pub const CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM: u32 = 3;
pub const CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_ERASE_0_REGION_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_GET_CLK_FREQ: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SWSETUP_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_LAYOUT_TABLE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SPI_FLASH: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_ETS_PRINTF_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB_NANO_FORMAT: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE: u32 = 1;
pub const CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT: u32 = 1;
pub const CONFIG_BOOT_ROM_LOG_ALWAYS_ON: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &[u8; 4usize] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_80M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ_80M_DEFAULT: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &[u8; 4usize] = b"80m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &[u8; 4usize] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &[u8; 14usize] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &[u8; 11usize] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &[u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &[u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_COMPILER_HIDE_PATHS_MACROS: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_UART_NONE: u32 = 1;
pub const CONFIG_APPTRACE_UART_TASK_PRIO: u32 = 1;
pub const CONFIG_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_BT_ENABLED: u32 = 1;
pub const CONFIG_BT_BLUEDROID_ENABLED: u32 = 1;
pub const CONFIG_BT_CONTROLLER_ENABLED: u32 = 1;
pub const CONFIG_BT_BTC_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_BT_BLUEDROID_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BT_BTU_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_BT_BLE_ENABLED: u32 = 1;
pub const CONFIG_BT_GATTS_ENABLE: u32 = 1;
pub const CONFIG_BT_GATT_MAX_SR_PROFILES: u32 = 8;
pub const CONFIG_BT_GATT_MAX_SR_ATTRIBUTES: u32 = 100;
pub const CONFIG_BT_GATTS_SEND_SERVICE_CHANGE_AUTO: u32 = 1;
pub const CONFIG_BT_GATTS_SEND_SERVICE_CHANGE_MODE: u32 = 0;
pub const CONFIG_BT_GATTC_ENABLE: u32 = 1;
pub const CONFIG_BT_GATTC_MAX_CACHE_CHAR: u32 = 40;
pub const CONFIG_BT_GATTC_CONNECT_RETRY_COUNT: u32 = 3;
pub const CONFIG_BT_BLE_SMP_ENABLE: u32 = 1;
pub const CONFIG_BT_LOG_HCI_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_HCI_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_BTM_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_BTM_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_L2CAP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_L2CAP_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_RFCOMM_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_RFCOMM_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_SDP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_SDP_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_GAP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_GAP_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_BNEP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_BNEP_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_PAN_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_PAN_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_A2D_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_A2D_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_AVDT_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_AVDT_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_AVCT_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_AVCT_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_AVRC_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_AVRC_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_MCA_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_MCA_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_HID_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_HID_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_APPL_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_APPL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_GATT_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_GATT_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_SMP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_SMP_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_BTIF_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_BTIF_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_BTC_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_BTC_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_OSI_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_OSI_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_LOG_BLUFI_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BT_LOG_BLUFI_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BT_ACL_CONNECTIONS: u32 = 4;
pub const CONFIG_BT_MULTI_CONNECTION_ENBALE: u32 = 1;
pub const CONFIG_BT_SMP_ENABLE: u32 = 1;
pub const CONFIG_BT_BLE_ESTAB_LINK_CONN_TOUT: u32 = 30;
pub const CONFIG_BT_MAX_DEVICE_NAME_LEN: u32 = 32;
pub const CONFIG_BT_BLE_RPA_TIMEOUT: u32 = 900;
pub const CONFIG_BT_BLE_50_FEATURES_SUPPORTED: u32 = 1;
pub const CONFIG_BT_CTRL_MODE_EFF: u32 = 1;
pub const CONFIG_BT_CTRL_BLE_MAX_ACT: u32 = 6;
pub const CONFIG_BT_CTRL_BLE_MAX_ACT_EFF: u32 = 6;
pub const CONFIG_BT_CTRL_BLE_STATIC_ACL_TX_BUF_NB: u32 = 0;
pub const CONFIG_BT_CTRL_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BT_CTRL_HCI_MODE_VHCI: u32 = 1;
pub const CONFIG_BT_CTRL_HCI_TL: u32 = 1;
pub const CONFIG_BT_CTRL_ADV_DUP_FILT_MAX: u32 = 30;
pub const CONFIG_BT_CTRL_HW_CCA_VAL: u32 = 20;
pub const CONFIG_BT_CTRL_HW_CCA_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_CE_LENGTH_TYPE_ORIG: u32 = 1;
pub const CONFIG_BT_CTRL_CE_LENGTH_TYPE_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_TX_ANTENNA_INDEX_0: u32 = 1;
pub const CONFIG_BT_CTRL_TX_ANTENNA_INDEX_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_RX_ANTENNA_INDEX_0: u32 = 1;
pub const CONFIG_BT_CTRL_RX_ANTENNA_INDEX_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_DFT_TX_POWER_LEVEL_P9: u32 = 1;
pub const CONFIG_BT_CTRL_DFT_TX_POWER_LEVEL_EFF: u32 = 11;
pub const CONFIG_BT_CTRL_BLE_ADV_REPORT_FLOW_CTRL_SUPP: u32 = 1;
pub const CONFIG_BT_CTRL_BLE_ADV_REPORT_FLOW_CTRL_NUM: u32 = 100;
pub const CONFIG_BT_CTRL_BLE_ADV_REPORT_DISCARD_THRSHOLD: u32 = 20;
pub const CONFIG_BT_CTRL_BLE_SCAN_DUPL: u32 = 1;
pub const CONFIG_BT_CTRL_SCAN_DUPL_TYPE_DEVICE: u32 = 1;
pub const CONFIG_BT_CTRL_SCAN_DUPL_TYPE: u32 = 0;
pub const CONFIG_BT_CTRL_SCAN_DUPL_CACHE_SIZE: u32 = 100;
pub const CONFIG_BT_CTRL_DUPL_SCAN_CACHE_REFRESH_PERIOD: u32 = 0;
pub const CONFIG_BT_CTRL_COEX_PHY_CODED_TX_RX_TLIM_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_SLEEP_MODE_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_SLEEP_CLOCK_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_HCI_TL_EFF: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_TWAI_ERRATA_FIX_LISTEN_ONLY_DOM: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 256;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ESP_TLS_USE_DS_PERIPHERAL: u32 = 1;
pub const CONFIG_ESP_COEX_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ETH_ENABLED: u32 = 1;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_ESP32C3_REV_MIN_3: u32 = 1;
pub const CONFIG_ESP32C3_REV_MIN_FULL: u32 = 3;
pub const CONFIG_ESP_REV_MIN_FULL: u32 = 3;
pub const CONFIG_ESP32C3_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_BT: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32C3_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32C3_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_SYSTIMER_STALL_WORKAROUND: u32 = 1;
pub const CONFIG_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_PERIPH_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_XTAL_FREQ: u32 = 40;
pub const CONFIG_LCD_PANEL_IO_FORMAT_BUF_SIZE: u32 = 32;
pub const CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_ESP_NETIF_TCPIP_LWIP: u32 = 1;
pub const CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_ENABLE_USB: u32 = 1;
pub const CONFIG_ESP_PHY_RF_CAL_PARTIAL: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_MODE: u32 = 0;
pub const CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS: u32 = 0;
pub const CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG: u32 = 1;
pub const CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_TASK_WDT_EN: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_INIT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP_SYSTEM_BROWNOUT_INTR: u32 = 1;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_TIMER_INTERRUPT_LEVEL: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_ISR_AFFINITY: u32 = 1;
pub const CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_IMPL_SYSTIMER: u32 = 1;
pub const CONFIG_ESP_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM: u32 = 7;
pub const CONFIG_ESP_COREDUMP_ENABLE_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_VOLUME_COUNT: u32 = 2;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_SECTOR_4096: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FATFS_VFS_FSTAT_BLKSIZE: u32 = 0;
pub const CONFIG_FREERTOS_UNICORE: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_OPTIMIZED_SCHEDULER: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1: u32 = 1;
pub const CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const CONFIG_FREERTOS_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_HAL_ASSERTION_EQUALS_SYSTEM: u32 = 1;
pub const CONFIG_HAL_DEFAULT_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_HAL_SPI_MASTER_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_HAL_SPI_SLAVE_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_IEEE802154_CCA_THRESHOLD: i32 = -60;
pub const CONFIG_IEEE802154_PENDING_TABLE_SIZE: u32 = 20;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT: u32 = 1;
pub const CONFIG_LOG_MAXIMUM_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LOG_TIMESTAMP_SOURCE_RTOS: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &[u8; 10usize] = b"espressif\0";
pub const CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_IP4_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP6_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP_REASS_MAX_PBUFS: u32 = 10;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_ESP_MLDV6_REPORT: u32 = 1;
pub const CONFIG_LWIP_MLDV6_TMR_INTERVAL: u32 = 40;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID: u32 = 1;
pub const CONFIG_LWIP_DHCP_OPTIONS_LEN: u32 = 68;
pub const CONFIG_LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const CONFIG_LWIP_DHCP_COARSE_TIMER_SECS: u32 = 1;
pub const CONFIG_LWIP_DHCPS: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_IPV4: u32 = 1;
pub const CONFIG_LWIP_IPV6: u32 = 1;
pub const CONFIG_LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION: u32 = 1;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_TMR_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 1500;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS: u32 = 5;
pub const CONFIG_LWIP_ICMP: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_SNTP_MAX_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_LWIP_BRIDGEIF_MAX_PORTS: u32 = 7;
pub const CONFIG_LWIP_ESP_LWIP_ASSERT: u32 = 1;
pub const CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_ROUTE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_ND6_GET_GW_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_INPUT_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE: u32 = 1;
pub const CONFIG_MBEDTLS_PKCS7_C: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS: u32 = 200;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_AES_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_MPI: u32 = 1;
pub const CONFIG_MBEDTLS_MPI_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_SHA: u32 = 1;
pub const CONFIG_MBEDTLS_ROM_MD5: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_DETERMINISTIC: u32 = 1;
pub const CONFIG_MBEDTLS_SHA512_C: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI: u32 = 1;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8usize] = b"pthread\0";
pub const CONFIG_MMU_PAGE_SIZE_64KB: u32 = 1;
pub const CONFIG_MMU_PAGE_MODE: &[u8; 5usize] = b"64KB\0";
pub const CONFIG_MMU_PAGE_SIZE: u32 = 65536;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_YIELD_DURING_ERASE: u32 = 1;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS: u32 = 20;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_TICKS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE: u32 = 8192;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC: u32 = 1;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_GD_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_ISSI_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_MXIC_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_WINBOND_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_BOYA_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_TH_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_TH_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_WS_TRANSPORT: u32 = 1;
pub const CONFIG_WS_BUFFER_SIZE: u32 = 1024;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_VFS_SUPPORT_IO: u32 = 1;
pub const CONFIG_VFS_SUPPORT_DIR: u32 = 1;
pub const CONFIG_VFS_SUPPORT_SELECT: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT: u32 = 30;
pub const CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN: u32 = 1;
pub const CONFIG_A2D_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_A2D_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_APPL_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_APPL_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_AVCT_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_AVCT_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_AVDT_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_AVDT_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_AVRC_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_AVRC_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BLE_ESTABLISH_LINK_CONNECTION_TIMEOUT: u32 = 30;
pub const CONFIG_BLE_SMP_ENABLE: u32 = 1;
pub const CONFIG_BLUEDROID_ENABLED: u32 = 1;
pub const CONFIG_BLUEDROID_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BLUFI_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BLUFI_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BNEP_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_BTC_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BTC_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_BTC_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BTH_LOG_SDP_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BTIF_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BTIF_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BTM_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_BTM_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_BTU_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_CONSOLE_UART: u32 = 1;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32C3_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32C3_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP32C3_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP32C3_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32C3_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP32C3_LIGHTSLEEP_GPIO_RESET_WORKAROUND: u32 = 1;
pub const CONFIG_ESP32C3_MEMPROT_FEATURE: u32 = 1;
pub const CONFIG_ESP32C3_MEMPROT_FEATURE_LOCK: u32 = 1;
pub const CONFIG_ESP32C3_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32C3_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32C3_TIME_SYSCALL_USE_RTC_SYSTIMER: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8usize] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU: u32 = 1;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_ESP_WIFI_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_GAP_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_GAP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_GATTC_ENABLE: u32 = 1;
pub const CONFIG_GATTS_ENABLE: u32 = 1;
pub const CONFIG_GATTS_SEND_SERVICE_CHANGE_AUTO: u32 = 1;
pub const CONFIG_GATTS_SEND_SERVICE_CHANGE_MODE: u32 = 0;
pub const CONFIG_GATT_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_GATT_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_HCI_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_HCI_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_HID_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_HID_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_L2CAP_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_L2CAP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_MCA_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_MCA_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_OSI_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_OSI_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_PAN_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_PAN_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_RFCOMM_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_RFCOMM_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_SDP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SMP_ENABLE: u32 = 1;
pub const CONFIG_SMP_INITIAL_TRACE_LEVEL: u32 = 2;
pub const CONFIG_SMP_TRACE_LEVEL_WARNING: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_NOT_FINISHED: u32 = 268;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const ESP_ERR_HW_CRYPTO_BASE: u32 = 49152;
pub const ESP_ERR_MEMPROT_BASE: u32 = 53248;
pub const ESP_EVENT_ANY_ID: i32 = -1;
pub const WIFI_OFFCHAN_TX_REQ: u32 = 1;
pub const WIFI_OFFCHAN_TX_CANCEL: u32 = 0;
pub const WIFI_ROC_REQ: u32 = 1;
pub const WIFI_ROC_CANCEL: u32 = 0;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const WIFI_PROTOCOL_11AX: u32 = 16;
pub const SAE_H2E_IDENTIFIER_LEN: u32 = 32;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 10;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_FILTER_MASK_DATA_MPDU: u32 = 16;
pub const WIFI_PROMIS_FILTER_MASK_DATA_AMPDU: u32 = 32;
pub const WIFI_PROMIS_FILTER_MASK_FCSFAIL: u32 = 64;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const ESP_WIFI_NAN_MAX_SVC_SUPPORTED: u32 = 2;
pub const ESP_WIFI_NAN_DATAPATH_MAX_PEERS: u32 = 2;
pub const ESP_WIFI_NDP_ROLE_INITIATOR: u32 = 1;
pub const ESP_WIFI_NDP_ROLE_RESPONDER: u32 = 2;
pub const ESP_WIFI_MAX_SVC_NAME_LEN: u32 = 256;
pub const ESP_WIFI_MAX_FILTER_LEN: u32 = 256;
pub const ESP_WIFI_MAX_SVC_INFO_LEN: u32 = 64;
pub const MAX_SSID_LEN: u32 = 32;
pub const MAX_PASSPHRASE_LEN: u32 = 64;
pub const MAX_WPS_AP_CRED: u32 = 3;
pub const WIFI_STATIS_BUFFER: u32 = 1;
pub const WIFI_STATIS_RXTX: u32 = 2;
pub const WIFI_STATIS_HW: u32 = 4;
pub const WIFI_STATIS_DIAG: u32 = 8;
pub const WIFI_STATIS_PS: u32 = 16;
pub const WIFI_STATIS_ALL: i32 = -1;
pub const ESP_WIFI_CRYPTO_VERSION: u32 = 1;
pub const ESP_WIFI_OS_ADAPTER_VERSION: u32 = 8;
pub const ESP_WIFI_OS_ADAPTER_MAGIC: u32 = 3735928495;
pub const OSI_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const OSI_QUEUE_SEND_FRONT: u32 = 0;
pub const OSI_QUEUE_SEND_BACK: u32 = 1;
pub const OSI_QUEUE_SEND_OVERWRITE: u32 = 2;
pub const ESP_ERR_WIFI_NOT_INIT: u32 = 12289;
pub const ESP_ERR_WIFI_NOT_STARTED: u32 = 12290;
pub const ESP_ERR_WIFI_NOT_STOPPED: u32 = 12291;
pub const ESP_ERR_WIFI_IF: u32 = 12292;
pub const ESP_ERR_WIFI_MODE: u32 = 12293;
pub const ESP_ERR_WIFI_STATE: u32 = 12294;
pub const ESP_ERR_WIFI_CONN: u32 = 12295;
pub const ESP_ERR_WIFI_NVS: u32 = 12296;
pub const ESP_ERR_WIFI_MAC: u32 = 12297;
pub const ESP_ERR_WIFI_SSID: u32 = 12298;
pub const ESP_ERR_WIFI_PASSWORD: u32 = 12299;
pub const ESP_ERR_WIFI_TIMEOUT: u32 = 12300;
pub const ESP_ERR_WIFI_WAKE_FAIL: u32 = 12301;
pub const ESP_ERR_WIFI_WOULD_BLOCK: u32 = 12302;
pub const ESP_ERR_WIFI_NOT_CONNECT: u32 = 12303;
pub const ESP_ERR_WIFI_POST: u32 = 12306;
pub const ESP_ERR_WIFI_INIT_STATE: u32 = 12307;
pub const ESP_ERR_WIFI_STOP_STATE: u32 = 12308;
pub const ESP_ERR_WIFI_NOT_ASSOC: u32 = 12309;
pub const ESP_ERR_WIFI_TX_DISALLOW: u32 = 12310;
pub const ESP_ERR_WIFI_TWT_FULL: u32 = 12311;
pub const ESP_ERR_WIFI_TWT_SETUP_TIMEOUT: u32 = 12312;
pub const WIFI_STATIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_CACHE_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const WIFI_CSI_ENABLED: u32 = 0;
pub const WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const WIFI_AMSDU_TX_ENABLED: u32 = 0;
pub const WIFI_NVS_ENABLED: u32 = 1;
pub const WIFI_NANO_FORMAT_ENABLED: u32 = 0;
pub const WIFI_INIT_CONFIG_MAGIC: u32 = 523190095;
pub const WIFI_DEFAULT_RX_BA_WIN: u32 = 6;
pub const WIFI_TASK_CORE_ID: u32 = 0;
pub const WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const WIFI_STA_DISCONNECTED_PM_ENABLED: u32 = 1;
pub const CONFIG_FEATURE_WPA3_SAE_BIT: u32 = 1;
pub const CONFIG_FEATURE_CACHE_TX_BUF_BIT: u32 = 2;
pub const CONFIG_FEATURE_FTM_INITIATOR_BIT: u32 = 4;
pub const CONFIG_FEATURE_FTM_RESPONDER_BIT: u32 = 8;
pub const ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE: u32 = 0;
pub const WIFI_LOG_SUBMODULE_ALL: u32 = 0;
pub const WIFI_LOG_SUBMODULE_INIT: u32 = 1;
pub const WIFI_LOG_SUBMODULE_IOCTL: u32 = 2;
pub const WIFI_LOG_SUBMODULE_CONN: u32 = 4;
pub const WIFI_LOG_SUBMODULE_SCAN: u32 = 8;
pub const ESP_CAL_DATA_CHECK_FAIL: u32 = 1;
pub const ESP_BT_CTRL_CONFIG_MAGIC_VAL: u32 = 1515890085;
pub const ESP_BT_CTRL_CONFIG_VERSION: u32 = 36708672;
pub const ESP_BT_HCI_TL_MAGIC_VALUE: u32 = 4208901805;
pub const ESP_BT_HCI_TL_VERSION: u32 = 65536;
pub const ESP_BT_HCI_TL_STATUS_OK: u32 = 0;
pub const BT_CTRL_BLE_MAX_ACT_LIMIT: u32 = 10;
pub const SLAVE_CE_LEN_MIN_DEFAULT: u32 = 5;
pub const SCAN_DUPLICATE_TYPE_VALUE: u32 = 0;
pub const NORMAL_SCAN_DUPLICATE_CACHE_SIZE: u32 = 100;
pub const SCAN_DUPLICATE_MODE_NORMAL_ADV_ONLY: u32 = 0;
pub const SCAN_DUPLICATE_MODE_NORMAL_ADV_MESH_ADV: u32 = 1;
pub const SCAN_DUPLICATE_MODE: u32 = 0;
pub const MESH_DUPLICATE_SCAN_CACHE_SIZE: u32 = 0;
pub const DUPL_SCAN_CACHE_REFRESH_PERIOD: u32 = 0;
pub const BT_CTRL_SCAN_BACKOFF_UPPERLIMITMAX: u32 = 0;
pub const BT_CTRL_AGC_RECORRECT_EN: u32 = 0;
pub const BT_CTRL_CODED_AGC_RECORRECT: u32 = 0;
pub const BT_CTRL_50_FEATURE_SUPPORT: u32 = 1;
pub const AGC_RECORRECT_EN: u32 = 0;
pub const CFG_MASK_BIT_SCAN_DUPLICATE_OPTION: u32 = 1;
pub const CFG_MASK: u32 = 1;
pub const BLE_HW_TARGET_CODE_CHIP_ECO0: u32 = 16842752;
pub const ESP_COEX_BLE_ST_MESH_CONFIG: u32 = 8;
pub const ESP_COEX_BLE_ST_MESH_TRAFFIC: u32 = 16;
pub const ESP_COEX_BLE_ST_MESH_STANDBY: u32 = 32;
pub const ESP_COEX_BT_ST_A2DP_STREAMING: u32 = 16;
pub const ESP_COEX_BT_ST_A2DP_PAUSED: u32 = 32;
pub const COEX_ADAPTER_VERSION: u32 = 2;
pub const COEX_ADAPTER_MAGIC: u32 = 3735928495;
pub const COEX_ADAPTER_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const ESP_ERR_ESPNOW_BASE: u32 = 12388;
pub const ESP_ERR_ESPNOW_NOT_INIT: u32 = 12389;
pub const ESP_ERR_ESPNOW_ARG: u32 = 12390;
pub const ESP_ERR_ESPNOW_NO_MEM: u32 = 12391;
pub const ESP_ERR_ESPNOW_FULL: u32 = 12392;
pub const ESP_ERR_ESPNOW_NOT_FOUND: u32 = 12393;
pub const ESP_ERR_ESPNOW_INTERNAL: u32 = 12394;
pub const ESP_ERR_ESPNOW_EXIST: u32 = 12395;
pub const ESP_ERR_ESPNOW_IF: u32 = 12396;
pub const ESP_NOW_ETH_ALEN: u32 = 6;
pub const ESP_NOW_KEY_LEN: u32 = 16;
pub const ESP_NOW_MAX_TOTAL_PEER_NUM: u32 = 20;
pub const ESP_NOW_MAX_ENCRYPT_PEER_NUM: u32 = 6;
pub const ESP_NOW_MAX_DATA_LEN: u32 = 250;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
pub const esp_log_level_e_ESP_LOG_NONE: esp_log_level_e = 0;
pub const esp_log_level_e_ESP_LOG_ERROR: esp_log_level_e = 1;
pub const esp_log_level_e_ESP_LOG_WARN: esp_log_level_e = 2;
pub const esp_log_level_e_ESP_LOG_INFO: esp_log_level_e = 3;
pub const esp_log_level_e_ESP_LOG_DEBUG: esp_log_level_e = 4;
pub const esp_log_level_e_ESP_LOG_VERBOSE: esp_log_level_e = 5;
pub type esp_log_level_e = crate::c_types::c_uint;
pub type TickType_t = u32;
pub type UBaseType_t = u32;
pub type BaseType_t = i32;
pub type QueueHandle_t = *mut crate::c_types::c_void;
pub type esp_netif_t = *mut crate::c_types::c_void;
pub type esp_netif_inherent_config_t = *mut crate::c_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ets_timer {
    pub next: *mut timer_adpt,
    pub expire: u32,
    pub period: u32,
    pub func: ::core::option::Option<unsafe extern "C" fn(priv_: *mut crate::c_types::c_void)>,
    pub priv_: *mut crate::c_types::c_void,
}
pub type size_t = crate::c_types::c_uint;
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = crate::c_types::c_uint;
pub type __blkcnt_t = crate::c_types::c_long;
pub type __blksize_t = crate::c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = crate::c_types::c_long;
pub type __pid_t = crate::c_types::c_int;
pub type __dev_t = crate::c_types::c_short;
pub type __uid_t = crate::c_types::c_ushort;
pub type __gid_t = crate::c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = crate::c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = crate::c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = crate::c_types::c_long;
pub type _fpos_t = crate::c_types::c_long;
pub type __size_t = crate::c_types::c_uint;
pub type _ssize_t = crate::c_types::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: crate::c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [crate::c_types::c_uchar; 4usize],
}
pub type _iconv_t = *mut crate::c_types::c_void;
pub type __clock_t = crate::c_types::c_ulong;
pub type __time_t = crate::c_types::c_long;
pub type __clockid_t = crate::c_types::c_ulong;
pub type __timer_t = crate::c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = crate::c_types::c_int;
pub type __nlink_t = crate::c_types::c_ushort;
pub type __suseconds_t = crate::c_types::c_long;
pub type __useconds_t = crate::c_types::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = crate::c_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: crate::c_types::c_int,
    pub _maxwds: crate::c_types::c_int,
    pub _sign: crate::c_types::c_int,
    pub _wds: crate::c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __tm {
    pub __tm_sec: crate::c_types::c_int,
    pub __tm_min: crate::c_types::c_int,
    pub __tm_hour: crate::c_types::c_int,
    pub __tm_mday: crate::c_types::c_int,
    pub __tm_mon: crate::c_types::c_int,
    pub __tm_year: crate::c_types::c_int,
    pub __tm_wday: crate::c_types::c_int,
    pub __tm_yday: crate::c_types::c_int,
    pub __tm_isdst: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut crate::c_types::c_void; 32usize],
    pub _dso_handle: [*mut crate::c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: crate::c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut crate::c_types::c_uchar,
    pub _size: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut crate::c_types::c_uchar,
    pub _r: crate::c_types::c_int,
    pub _w: crate::c_types::c_int,
    pub _flags: crate::c_types::c_short,
    pub _file: crate::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::c_types::c_int,
    pub _data: *mut _reent,
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut crate::c_types::c_uchar,
    pub _r: crate::c_types::c_int,
    pub _w: crate::c_types::c_int,
    pub _flags: crate::c_types::c_short,
    pub _file: crate::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut crate::c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *mut crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
        ) -> _ssize_t,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
            arg3: _fpos_t,
            arg4: crate::c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut crate::c_types::c_uchar,
    pub _ur: crate::c_types::c_int,
    pub _ubuf: [crate::c_types::c_uchar; 3usize],
    pub _nbuf: [crate::c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: crate::c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: crate::c_types::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: crate::c_types::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rand48 {
    pub _seed: [crate::c_types::c_ushort; 3usize],
    pub _mult: [crate::c_types::c_ushort; 3usize],
    pub _add: crate::c_types::c_ushort,
    pub _rand_next: crate::c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: crate::c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut crate::c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [crate::c_types::c_char; 8usize],
    pub _getdate_err: crate::c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: crate::c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: crate::c_types::c_int,
    pub _emergency: *mut crate::c_types::c_char,
    pub __sdidinit: crate::c_types::c_int,
    pub _unspecified_locale_info: crate::c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: crate::c_types::c_int,
    pub _cvtlen: crate::c_types::c_int,
    pub _cvtbuf: *mut crate::c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut crate::c_types::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: crate::c_types::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut crate::c_types::c_char,
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub fn __assert(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: *const crate::c_types::c_char,
    );
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = crate::c_types::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = crate::c_types::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: crate::c_types::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type fd_mask = crate::c_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: crate::c_types::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn pselect(
        __n: crate::c_types::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> crate::c_types::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = crate::c_types::c_uchar;
pub type u_short = crate::c_types::c_ushort;
pub type u_int = crate::c_types::c_uint;
pub type u_long = crate::c_types::c_ulong;
pub type ushort = crate::c_types::c_ushort;
pub type uint = crate::c_types::c_uint;
pub type ulong = crate::c_types::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = crate::c_types::c_ulong;
pub type daddr_t = crate::c_types::c_long;
pub type caddr_t = *mut crate::c_types::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param {
    pub sched_priority: crate::c_types::c_int,
}
extern "C" {
    pub fn sched_yield() -> crate::c_types::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: crate::c_types::c_int,
    pub stackaddr: *mut crate::c_types::c_void,
    pub stacksize: crate::c_types::c_int,
    pub contentionscope: crate::c_types::c_int,
    pub inheritsched: crate::c_types::c_int,
    pub schedpolicy: crate::c_types::c_int,
    pub schedparam: sched_param,
    pub detachstate: crate::c_types::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: crate::c_types::c_int,
    pub type_: crate::c_types::c_int,
    pub recursive: crate::c_types::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: crate::c_types::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: crate::c_types::c_int,
    pub init_executed: crate::c_types::c_int,
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn printf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const crate::c_types::c_char,
        arg2: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn fputc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const crate::c_types::c_char, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getchar() -> crate::c_types::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn putc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putchar(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn puts(arg1: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ungetc(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut crate::c_types::c_void,
        _size: crate::c_types::c_uint,
        _n: crate::c_types::c_uint,
        arg2: *mut FILE,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const crate::c_types::c_void,
        _size: crate::c_types::c_uint,
        _n: crate::c_types::c_uint,
        arg2: *mut FILE,
    ) -> crate::c_types::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: crate::c_types::c_long,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> crate::c_types::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn perror(arg1: *const crate::c_types::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const crate::c_types::c_char,
        _type: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn remove(arg1: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_uint,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_uint,
        arg3: *const crate::c_types::c_char,
        arg4: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const crate::c_types::c_char,
        arg2: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __builtin_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut size_t,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut size_t,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const crate::c_types::c_char, ...) -> crate::c_types::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: size_t,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut size_t,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *mut size_t,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const crate::c_types::c_char,
        arg2: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const crate::c_types::c_char,
        arg2: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut crate::c_types::c_char,
        arg2: size_t,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fdopen(arg1: crate::c_types::c_int, arg2: *const crate::c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putw(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> crate::c_types::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut crate::c_types::c_void,
        arg2: size_t,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut crate::c_types::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: crate::c_types::c_int,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut size_t,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut size_t,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: size_t,
        arg4: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: crate::c_types::c_long,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const crate::c_types::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const crate::c_types::c_char)
        -> crate::c_types::c_int;
}
extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const crate::c_types::c_char,
        _new: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: size_t,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: size_t,
        arg4: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        ...
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut size_t,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *mut size_t,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: size_t,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: size_t,
        arg4: *const crate::c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *const crate::c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *mut size_t,
        arg3: crate::c_types::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *mut size_t,
        arg3: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: crate::c_types::c_int, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut crate::c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const crate::c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: crate::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const crate::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *mut crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *const crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __off: fpos_t,
                __whence: crate::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut crate::c_types::c_void) -> crate::c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const crate::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *mut crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __buf: *const crate::c_types::c_char,
                __n: crate::c_types::c_int,
            ) -> crate::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::c_types::c_void,
                __off: fpos_t,
                __whence: crate::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut crate::c_types::c_void) -> crate::c_types::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: crate::c_types::c_int,
    pub rem: crate::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: crate::c_types::c_long,
    pub rem: crate::c_types::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: crate::c_types::c_longlong,
    pub rem: crate::c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::c_types::c_void,
        arg2: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> crate::c_types::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut crate::c_types::c_void, arg2: size_t);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const crate::c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const crate::c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const crate::c_types::c_void,
        __base: *const crate::c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: crate::c_types::c_uint,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn div(__numer: crate::c_types::c_int, __denom: crate::c_types::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: crate::c_types::c_int);
}
extern "C" {
    pub fn free(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn getenv(__string: *const crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const crate::c_types::c_char,
        arg2: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut crate::c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut crate::c_types::c_char,
        arg2: *const *mut crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: crate::c_types::c_long) -> crate::c_types::c_long;
}
extern "C" {
    pub fn ldiv(__numer: crate::c_types::c_long, __denom: crate::c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: crate::c_types::c_uint) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const crate::c_types::c_char, arg2: size_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: size_t,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const crate::c_types::c_char,
        arg3: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut crate::c_types::c_char, arg2: wchar_t) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const crate::c_types::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut crate::c_types::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: *const wchar_t,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut crate::c_types::c_char,
        arg2: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut crate::c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> crate::c_types::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut crate::c_types::c_void,
        arg2: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut crate::c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut crate::c_types::c_void, arg2: size_t)
        -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const crate::c_types::c_char,
        resolved_path: *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: crate::c_types::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const crate::c_types::c_char) -> crate::c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: crate::c_types::c_long) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: crate::c_types::c_long,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: crate::c_types::c_int, arg2: *mut crate::c_types::c_void),
        >,
        __arg: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: crate::c_types::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: size_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
        __value: *const crate::c_types::c_char,
        __overwrite: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: crate::c_types::c_int,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: crate::c_types::c_int,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut crate::c_types::c_uint) -> crate::c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> crate::c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> crate::c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut crate::c_types::c_ushort) -> crate::c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> crate::c_types::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut crate::c_types::c_ushort) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_ushort,
    ) -> *mut crate::c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: crate::c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: crate::c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: crate::c_types::c_uint,
        arg2: *mut crate::c_types::c_char,
        arg3: size_t,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn random() -> crate::c_types::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut crate::c_types::c_char) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: crate::c_types::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const crate::c_types::c_char) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const crate::c_types::c_char,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: crate::c_types::c_longlong) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: crate::c_types::c_longlong,
        __denom: crate::c_types::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const crate::c_types::c_char,
        __end_PTR: *mut *mut crate::c_types::c_char,
        __base: crate::c_types::c_int,
    ) -> crate::c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const crate::c_types::c_char) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut crate::c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: crate::c_types::c_int,
        arg4: crate::c_types::c_int,
        arg5: *mut crate::c_types::c_int,
        arg6: *mut crate::c_types::c_int,
        arg7: *mut *mut crate::c_types::c_char,
    ) -> *mut crate::c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: size_t) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: size_t, arg3: size_t) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut crate::c_types::c_void,
        arg3: size_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut crate::c_types::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const crate::c_types::c_char,
        arg2: *const crate::c_types::c_char,
        arg3: crate::c_types::c_uint,
        arg4: *const crate::c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut crate::c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        __thunk: *mut crate::c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *const crate::c_types::c_void,
                arg3: *const crate::c_types::c_void,
            ) -> crate::c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const crate::c_types::c_char,
        arg3: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(
        arg1: *const crate::c_types::c_char,
        arg2: *mut *mut crate::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn aligned_alloc(arg1: size_t, arg2: size_t) -> *mut crate::c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: crate::c_types::c_int);
}
pub type esp_err_t = crate::c_types::c_int;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table and"]
    #[doc = " returns its string representation."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table of"]
    #[doc = " esp_err_t errors and returns its string representation. If the error code"]
    #[doc = " is not found then it is attempted to be found among system errors."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @param[out] buf buffer where the error message should be written"]
    #[doc = " @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte)."]
    #[doc = " @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut crate::c_types::c_char,
        buflen: size_t,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        function: *const crate::c_types::c_char,
        expression: *const crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        function: *const crate::c_types::c_char,
        expression: *const crate::c_types::c_char,
    );
}
#[doc = "< Station interface"]
pub const esp_interface_t_ESP_IF_WIFI_STA: esp_interface_t = 0;
#[doc = "< Soft-AP interface"]
pub const esp_interface_t_ESP_IF_WIFI_AP: esp_interface_t = 1;
#[doc = "< NAN interface"]
pub const esp_interface_t_ESP_IF_WIFI_NAN: esp_interface_t = 2;
#[doc = "< Ethernet interface"]
pub const esp_interface_t_ESP_IF_ETH: esp_interface_t = 3;
pub const esp_interface_t_ESP_IF_MAX: esp_interface_t = 4;
pub type esp_interface_t = crate::c_types::c_uint;
pub type esp_event_base_t = *const crate::c_types::c_char;
pub type esp_event_loop_handle_t = *mut crate::c_types::c_void;
pub type esp_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_handler_arg: *mut crate::c_types::c_void,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut crate::c_types::c_void,
    ),
>;
pub type esp_event_handler_instance_t = *mut crate::c_types::c_void;
#[doc = "< null mode"]
pub const wifi_mode_t_WIFI_MODE_NULL: wifi_mode_t = 0;
#[doc = "< WiFi station mode"]
pub const wifi_mode_t_WIFI_MODE_STA: wifi_mode_t = 1;
#[doc = "< WiFi soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_AP: wifi_mode_t = 2;
#[doc = "< WiFi station + soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_APSTA: wifi_mode_t = 3;
#[doc = "< WiFi NAN mode"]
pub const wifi_mode_t_WIFI_MODE_NAN: wifi_mode_t = 4;
pub const wifi_mode_t_WIFI_MODE_MAX: wifi_mode_t = 5;
pub type wifi_mode_t = crate::c_types::c_uint;
pub const wifi_interface_t_WIFI_IF_STA: wifi_interface_t = 0;
pub const wifi_interface_t_WIFI_IF_AP: wifi_interface_t = 1;
pub const wifi_interface_t_WIFI_IF_MAX: wifi_interface_t = 2;
pub type wifi_interface_t = crate::c_types::c_uint;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_AUTO: wifi_country_policy_t = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_MANUAL: wifi_country_policy_t = 1;
pub type wifi_country_policy_t = crate::c_types::c_uint;
#[doc = " @brief Structure describing WiFi country-based regional restrictions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< country code string"]
    pub cc: [crate::c_types::c_char; 3usize],
    #[doc = "< start channel"]
    pub schan: u8,
    #[doc = "< total channel number"]
    pub nchan: u8,
    #[doc = "< This field is used for getting WiFi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power."]
    pub max_tx_power: i8,
    #[doc = "< country policy"]
    pub policy: wifi_country_policy_t,
}
#[doc = "< authenticate mode : open"]
pub const wifi_auth_mode_t_WIFI_AUTH_OPEN: wifi_auth_mode_t = 0;
#[doc = "< authenticate mode : WEP"]
pub const wifi_auth_mode_t_WIFI_AUTH_WEP: wifi_auth_mode_t = 1;
#[doc = "< authenticate mode : WPA_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_PSK: wifi_auth_mode_t = 2;
#[doc = "< authenticate mode : WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_PSK: wifi_auth_mode_t = 3;
#[doc = "< authenticate mode : WPA_WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_WPA2_PSK: wifi_auth_mode_t = 4;
#[doc = "< authenticate mode : WPA2_ENTERPRISE"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_ENTERPRISE: wifi_auth_mode_t = 5;
#[doc = "< authenticate mode : WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_PSK: wifi_auth_mode_t = 6;
#[doc = "< authenticate mode : WPA2_WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_WPA3_PSK: wifi_auth_mode_t = 7;
#[doc = "< authenticate mode : WAPI_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WAPI_PSK: wifi_auth_mode_t = 8;
#[doc = "< authenticate mode : OWE"]
pub const wifi_auth_mode_t_WIFI_AUTH_OWE: wifi_auth_mode_t = 9;
pub const wifi_auth_mode_t_WIFI_AUTH_MAX: wifi_auth_mode_t = 10;
pub type wifi_auth_mode_t = crate::c_types::c_uint;
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED: wifi_err_reason_t = 1;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_EXPIRE: wifi_err_reason_t = 2;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_LEAVE: wifi_err_reason_t = 3;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_EXPIRE: wifi_err_reason_t = 4;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_TOOMANY: wifi_err_reason_t = 5;
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHED: wifi_err_reason_t = 6;
pub const wifi_err_reason_t_WIFI_REASON_NOT_ASSOCED: wifi_err_reason_t = 7;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_LEAVE: wifi_err_reason_t = 8;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_NOT_AUTHED: wifi_err_reason_t = 9;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_PWRCAP_BAD: wifi_err_reason_t = 10;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_SUPCHAN_BAD: wifi_err_reason_t = 11;
pub const wifi_err_reason_t_WIFI_REASON_BSS_TRANSITION_DISASSOC: wifi_err_reason_t = 12;
pub const wifi_err_reason_t_WIFI_REASON_IE_INVALID: wifi_err_reason_t = 13;
pub const wifi_err_reason_t_WIFI_REASON_MIC_FAILURE: wifi_err_reason_t = 14;
pub const wifi_err_reason_t_WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 15;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT: wifi_err_reason_t = 16;
pub const wifi_err_reason_t_WIFI_REASON_IE_IN_4WAY_DIFFERS: wifi_err_reason_t = 17;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_CIPHER_INVALID: wifi_err_reason_t = 18;
pub const wifi_err_reason_t_WIFI_REASON_PAIRWISE_CIPHER_INVALID: wifi_err_reason_t = 19;
pub const wifi_err_reason_t_WIFI_REASON_AKMP_INVALID: wifi_err_reason_t = 20;
pub const wifi_err_reason_t_WIFI_REASON_UNSUPP_RSN_IE_VERSION: wifi_err_reason_t = 21;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_RSN_IE_CAP: wifi_err_reason_t = 22;
pub const wifi_err_reason_t_WIFI_REASON_802_1X_AUTH_FAILED: wifi_err_reason_t = 23;
pub const wifi_err_reason_t_WIFI_REASON_CIPHER_SUITE_REJECTED: wifi_err_reason_t = 24;
pub const wifi_err_reason_t_WIFI_REASON_TDLS_PEER_UNREACHABLE: wifi_err_reason_t = 25;
pub const wifi_err_reason_t_WIFI_REASON_TDLS_UNSPECIFIED: wifi_err_reason_t = 26;
pub const wifi_err_reason_t_WIFI_REASON_SSP_REQUESTED_DISASSOC: wifi_err_reason_t = 27;
pub const wifi_err_reason_t_WIFI_REASON_NO_SSP_ROAMING_AGREEMENT: wifi_err_reason_t = 28;
pub const wifi_err_reason_t_WIFI_REASON_BAD_CIPHER_OR_AKM: wifi_err_reason_t = 29;
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHORIZED_THIS_LOCATION: wifi_err_reason_t = 30;
pub const wifi_err_reason_t_WIFI_REASON_SERVICE_CHANGE_PERCLUDES_TS: wifi_err_reason_t = 31;
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED_QOS: wifi_err_reason_t = 32;
pub const wifi_err_reason_t_WIFI_REASON_NOT_ENOUGH_BANDWIDTH: wifi_err_reason_t = 33;
pub const wifi_err_reason_t_WIFI_REASON_MISSING_ACKS: wifi_err_reason_t = 34;
pub const wifi_err_reason_t_WIFI_REASON_EXCEEDED_TXOP: wifi_err_reason_t = 35;
pub const wifi_err_reason_t_WIFI_REASON_STA_LEAVING: wifi_err_reason_t = 36;
pub const wifi_err_reason_t_WIFI_REASON_END_BA: wifi_err_reason_t = 37;
pub const wifi_err_reason_t_WIFI_REASON_UNKNOWN_BA: wifi_err_reason_t = 38;
pub const wifi_err_reason_t_WIFI_REASON_TIMEOUT: wifi_err_reason_t = 39;
pub const wifi_err_reason_t_WIFI_REASON_PEER_INITIATED: wifi_err_reason_t = 46;
pub const wifi_err_reason_t_WIFI_REASON_AP_INITIATED: wifi_err_reason_t = 47;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FT_ACTION_FRAME_COUNT: wifi_err_reason_t = 48;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_PMKID: wifi_err_reason_t = 49;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_MDE: wifi_err_reason_t = 50;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FTE: wifi_err_reason_t = 51;
pub const wifi_err_reason_t_WIFI_REASON_TRANSMISSION_LINK_ESTABLISH_FAILED: wifi_err_reason_t = 67;
pub const wifi_err_reason_t_WIFI_REASON_ALTERATIVE_CHANNEL_OCCUPIED: wifi_err_reason_t = 68;
pub const wifi_err_reason_t_WIFI_REASON_BEACON_TIMEOUT: wifi_err_reason_t = 200;
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND: wifi_err_reason_t = 201;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_FAIL: wifi_err_reason_t = 202;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_FAIL: wifi_err_reason_t = 203;
pub const wifi_err_reason_t_WIFI_REASON_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 204;
pub const wifi_err_reason_t_WIFI_REASON_CONNECTION_FAIL: wifi_err_reason_t = 205;
pub const wifi_err_reason_t_WIFI_REASON_AP_TSF_RESET: wifi_err_reason_t = 206;
pub const wifi_err_reason_t_WIFI_REASON_ROAMING: wifi_err_reason_t = 207;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_COMEBACK_TIME_TOO_LONG: wifi_err_reason_t = 208;
pub const wifi_err_reason_t_WIFI_REASON_SA_QUERY_TIMEOUT: wifi_err_reason_t = 209;
pub type wifi_err_reason_t = crate::c_types::c_uint;
#[doc = "< the channel width is HT20"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_NONE: wifi_second_chan_t = 0;
#[doc = "< the channel width is HT40 and the secondary channel is above the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_ABOVE: wifi_second_chan_t = 1;
#[doc = "< the channel width is HT40 and the secondary channel is below the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_BELOW: wifi_second_chan_t = 2;
pub type wifi_second_chan_t = crate::c_types::c_uint;
#[doc = "< active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
pub type wifi_scan_type_t = crate::c_types::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< maximum active scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_time_t {
    #[doc = "< active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< passive scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub passive: u32,
}
#[doc = " @brief Parameters for an SSID scan."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_config_t {
    #[doc = "< SSID of AP"]
    pub ssid: *mut u8,
    #[doc = "< MAC address of AP"]
    pub bssid: *mut u8,
    #[doc = "< channel, scan the specific channel"]
    pub channel: u8,
    #[doc = "< enable to scan AP whose SSID is hidden"]
    pub show_hidden: bool,
    #[doc = "< scan type, active or passive"]
    pub scan_type: wifi_scan_type_t,
    #[doc = "< scan time per channel"]
    pub scan_time: wifi_scan_time_t,
}
#[doc = "< the cipher type is none"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_NONE: wifi_cipher_type_t = 0;
#[doc = "< the cipher type is WEP40"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP40: wifi_cipher_type_t = 1;
#[doc = "< the cipher type is WEP104"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP104: wifi_cipher_type_t = 2;
#[doc = "< the cipher type is TKIP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP: wifi_cipher_type_t = 3;
#[doc = "< the cipher type is CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_CCMP: wifi_cipher_type_t = 4;
#[doc = "< the cipher type is TKIP and CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP_CCMP: wifi_cipher_type_t = 5;
#[doc = "< the cipher type is AES-CMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_CMAC128: wifi_cipher_type_t = 6;
#[doc = "< the cipher type is SMS4"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_SMS4: wifi_cipher_type_t = 7;
#[doc = "< the cipher type is GCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP: wifi_cipher_type_t = 8;
#[doc = "< the cipher type is GCMP-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP256: wifi_cipher_type_t = 9;
#[doc = "< the cipher type is AES-GMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC128: wifi_cipher_type_t = 10;
#[doc = "< the cipher type is AES-GMAC-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC256: wifi_cipher_type_t = 11;
#[doc = "< the cipher type is unknown"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_UNKNOWN: wifi_cipher_type_t = 12;
pub type wifi_cipher_type_t = crate::c_types::c_uint;
#[doc = "< WiFi antenna 0"]
pub const wifi_ant_t_WIFI_ANT_ANT0: wifi_ant_t = 0;
#[doc = "< WiFi antenna 1"]
pub const wifi_ant_t_WIFI_ANT_ANT1: wifi_ant_t = 1;
#[doc = "< Invalid WiFi antenna"]
pub const wifi_ant_t_WIFI_ANT_MAX: wifi_ant_t = 2;
#[doc = " @brief WiFi antenna"]
#[doc = ""]
pub type wifi_ant_t = crate::c_types::c_uint;
#[doc = " @brief Description of a WiFi AP HE Info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_he_ap_info_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< in M-BSSID set, identifies the nontransmitted BSSID"]
    pub bssid_index: u8,
}
impl wifi_he_ap_info_t {
    #[inline]
    pub fn bss_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_bss_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn partial_bss_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_partial_bss_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bss_color_disabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bss_color_disabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bss_color: u8,
        partial_bss_color: u8,
        bss_color_disabled: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let bss_color: u8 = unsafe { ::core::mem::transmute(bss_color) };
            bss_color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let partial_bss_color: u8 = unsafe { ::core::mem::transmute(partial_bss_color) };
            partial_bss_color as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bss_color_disabled: u8 = unsafe { ::core::mem::transmute(bss_color_disabled) };
            bss_color_disabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Description of a WiFi AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_record_t {
    #[doc = "< MAC address of AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 33usize],
    #[doc = "< channel of AP"]
    pub primary: u8,
    #[doc = "< secondary channel of AP"]
    pub second: wifi_second_chan_t,
    #[doc = "< signal strength of AP"]
    pub rssi: i8,
    #[doc = "< authmode of AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< pairwise cipher of AP"]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< group cipher of AP"]
    pub group_cipher: wifi_cipher_type_t,
    #[doc = "< antenna used to receive beacon from AP"]
    pub ant: wifi_ant_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< country information of AP"]
    pub country: wifi_country_t,
    #[doc = "< HE AP info"]
    pub he_ap: wifi_he_ap_info_t,
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ax(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_responder(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_responder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_initiator(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_initiator(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        phy_11ax: u32,
        wps: u32,
        ftm_responder: u32,
        ftm_initiator: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let phy_11ax: u32 = unsafe { ::core::mem::transmute(phy_11ax) };
            phy_11ax as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ftm_responder: u32 = unsafe { ::core::mem::transmute(ftm_responder) };
            ftm_responder as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ftm_initiator: u32 = unsafe { ::core::mem::transmute(ftm_initiator) };
            ftm_initiator as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Do fast scan, scan will end after find SSID match AP"]
pub const wifi_scan_method_t_WIFI_FAST_SCAN: wifi_scan_method_t = 0;
#[doc = "< All channel scan, scan will end after scan all the channel"]
pub const wifi_scan_method_t_WIFI_ALL_CHANNEL_SCAN: wifi_scan_method_t = 1;
pub type wifi_scan_method_t = crate::c_types::c_uint;
#[doc = "< Sort match AP in scan list by RSSI"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SIGNAL: wifi_sort_method_t = 0;
#[doc = "< Sort match AP in scan list by security mode"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SECURITY: wifi_sort_method_t = 1;
pub type wifi_sort_method_t = crate::c_types::c_uint;
#[doc = " @brief Structure describing parameters for a WiFi fast scan"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_threshold_t {
    #[doc = "< The minimum rssi to accept in the fast scan mode"]
    pub rssi: i8,
    #[doc = "< The weakest authmode to accept in the fast scan mode"]
    #[doc = "Note: Incase this value is not set and password is set as per WPA2 standards(password len >= 8), it will be defaulted to WPA2 and device won't connect to deprecated WEP/WPA networks. Please set authmode threshold as WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK to connect to WEP/WPA networks"]
    pub authmode: wifi_auth_mode_t,
}
#[doc = "< No power save"]
pub const wifi_ps_type_t_WIFI_PS_NONE: wifi_ps_type_t = 0;
#[doc = "< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period"]
pub const wifi_ps_type_t_WIFI_PS_MIN_MODEM: wifi_ps_type_t = 1;
#[doc = "< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t"]
pub const wifi_ps_type_t_WIFI_PS_MAX_MODEM: wifi_ps_type_t = 2;
pub type wifi_ps_type_t = crate::c_types::c_uint;
pub const wifi_bandwidth_t_WIFI_BW_HT20: wifi_bandwidth_t = 1;
pub const wifi_bandwidth_t_WIFI_BW_HT40: wifi_bandwidth_t = 2;
pub type wifi_bandwidth_t = crate::c_types::c_uint;
#[doc = " Configuration structure for Protected Management Frame"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_pmf_config_t {
    #[doc = "< Deprecated variable. Device will always connect in PMF mode if other device also advertizes PMF capability."]
    pub capable: bool,
    #[doc = "< Advertizes that Protected Management Frame is required. Device will not associate to non-PMF capable devices."]
    pub required: bool,
}
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_UNSPECIFIED: wifi_sae_pwe_method_t = 0;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HUNT_AND_PECK: wifi_sae_pwe_method_t = 1;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HASH_TO_ELEMENT: wifi_sae_pwe_method_t = 2;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_BOTH: wifi_sae_pwe_method_t = 3;
#[doc = " Configuration for SAE PWE derivation"]
pub type wifi_sae_pwe_method_t = crate::c_types::c_uint;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_AUTOMATIC: wifi_sae_pk_mode_t = 0;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_ONLY: wifi_sae_pk_mode_t = 1;
pub const wifi_sae_pk_mode_t_WPA3_SAE_PK_MODE_DISABLED: wifi_sae_pk_mode_t = 2;
#[doc = " Configuration for SAE-PK"]
pub type wifi_sae_pk_mode_t = crate::c_types::c_uint;
#[doc = " @brief Soft-AP configuration settings for the device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_config_t {
    #[doc = "< SSID of soft-AP. If ssid_len field is 0, this must be a Null terminated string. Otherwise, length is set according to ssid_len."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of soft-AP."]
    pub password: [u8; 64usize],
    #[doc = "< Optional length of SSID field."]
    pub ssid_len: u8,
    #[doc = "< Channel of soft-AP"]
    pub channel: u8,
    #[doc = "< Auth mode of soft-AP. Do not support AUTH_WEP, AUTH_WAPI_PSK and AUTH_OWE in soft-AP mode. When the auth mode is set to WPA2_PSK, WPA2_WPA3_PSK or WPA3_PSK, the pairwise cipher will be overwritten with WIFI_CIPHER_TYPE_CCMP."]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Broadcast SSID or not, default 0, broadcast the SSID"]
    pub ssid_hidden: u8,
    #[doc = "< Max number of stations allowed to connect in"]
    pub max_connection: u8,
    #[doc = "< Beacon interval which should be multiples of 100. Unit: TU(time unit, 1 TU = 1024 us). Range: 100 ~ 60000. Default value: 100"]
    pub beacon_interval: u16,
    #[doc = "< Pairwise cipher of SoftAP, group cipher will be derived using this. Cipher values are valid starting from WIFI_CIPHER_TYPE_TKIP, enum values before that will be considered as invalid and default cipher suites(TKIP+CCMP) will be used. Valid cipher suites in softAP mode are WIFI_CIPHER_TYPE_TKIP, WIFI_CIPHER_TYPE_CCMP and WIFI_CIPHER_TYPE_TKIP_CCMP."]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< Enable FTM Responder mode"]
    pub ftm_responder: bool,
    #[doc = "< Configuration for Protected Management Frame"]
    pub pmf_cfg: wifi_pmf_config_t,
    #[doc = "< Configuration for SAE PWE derivation method"]
    pub sae_pwe_h2e: wifi_sae_pwe_method_t,
}
#[doc = " @brief STA configuration settings for the device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_config_t {
    #[doc = "< SSID of target AP."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of target AP."]
    pub password: [u8; 64usize],
    #[doc = "< do all channel scan or fast scan"]
    pub scan_method: wifi_scan_method_t,
    #[doc = "< whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of target AP. Set to 1~13 to scan starting from the specified channel before connecting to AP. If the channel of AP is unknown, set it to 0."]
    pub channel: u8,
    #[doc = "< Listen interval for ESP32 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0."]
    pub listen_interval: u16,
    #[doc = "< sort the connect AP in the list by rssi or security mode"]
    pub sort_method: wifi_sort_method_t,
    #[doc = "< When sort_method is set, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used."]
    pub threshold: wifi_scan_threshold_t,
    #[doc = "< Configuration for Protected Management Frame. Will be advertised in RSN Capabilities in RSN IE."]
    pub pmf_cfg: wifi_pmf_config_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Configuration for SAE PWE derivation method"]
    pub sae_pwe_h2e: wifi_sae_pwe_method_t,
    #[doc = "< Configuration for SAE-PK (Public Key) Authentication method"]
    pub sae_pk_mode: wifi_sae_pk_mode_t,
    #[doc = "< Number of connection retries station will do before moving to next AP. scan_method should be set as WIFI_ALL_CHANNEL_SCAN to use this config."]
    #[doc = "Note: Enabling this may cause connection time to increase incase best AP doesn't behave properly."]
    pub failure_retry_cnt: u8,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Password identifier for H2E. this needs to be null terminated string"]
    pub sae_h2e_identifier: [u8; 32usize],
}
impl wifi_sta_config_t {
    #[inline]
    pub fn rm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbo_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mbo_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ft_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ft_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owe_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_owe_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transition_disable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transition_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rm_enabled: u32,
        btm_enabled: u32,
        mbo_enabled: u32,
        ft_enabled: u32,
        owe_enabled: u32,
        transition_disable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rm_enabled: u32 = unsafe { ::core::mem::transmute(rm_enabled) };
            rm_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let btm_enabled: u32 = unsafe { ::core::mem::transmute(btm_enabled) };
            btm_enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mbo_enabled: u32 = unsafe { ::core::mem::transmute(mbo_enabled) };
            mbo_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ft_enabled: u32 = unsafe { ::core::mem::transmute(ft_enabled) };
            ft_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let owe_enabled: u32 = unsafe { ::core::mem::transmute(owe_enabled) };
            owe_enabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let transition_disable: u32 = unsafe { ::core::mem::transmute(transition_disable) };
            transition_disable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn he_dcm_set(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_dcm_max_constellation_tx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_max_constellation_tx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn he_dcm_max_constellation_rx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_he_dcm_max_constellation_rx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn he_mcs9_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_mcs9_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_su_beamformee_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_su_beamformee_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_su_bmforming_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_su_bmforming_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_mu_bmforming_partial_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_mu_bmforming_partial_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_trig_cqi_feedback_disabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_he_trig_cqi_feedback_disabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn he_reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_he_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        he_dcm_set: u32,
        he_dcm_max_constellation_tx: u32,
        he_dcm_max_constellation_rx: u32,
        he_mcs9_enabled: u32,
        he_su_beamformee_disabled: u32,
        he_trig_su_bmforming_feedback_disabled: u32,
        he_trig_mu_bmforming_partial_feedback_disabled: u32,
        he_trig_cqi_feedback_disabled: u32,
        he_reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let he_dcm_set: u32 = unsafe { ::core::mem::transmute(he_dcm_set) };
            he_dcm_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let he_dcm_max_constellation_tx: u32 =
                unsafe { ::core::mem::transmute(he_dcm_max_constellation_tx) };
            he_dcm_max_constellation_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let he_dcm_max_constellation_rx: u32 =
                unsafe { ::core::mem::transmute(he_dcm_max_constellation_rx) };
            he_dcm_max_constellation_rx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let he_mcs9_enabled: u32 = unsafe { ::core::mem::transmute(he_mcs9_enabled) };
            he_mcs9_enabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let he_su_beamformee_disabled: u32 =
                unsafe { ::core::mem::transmute(he_su_beamformee_disabled) };
            he_su_beamformee_disabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let he_trig_su_bmforming_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_su_bmforming_feedback_disabled) };
            he_trig_su_bmforming_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let he_trig_mu_bmforming_partial_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_mu_bmforming_partial_feedback_disabled) };
            he_trig_mu_bmforming_partial_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let he_trig_cqi_feedback_disabled: u32 =
                unsafe { ::core::mem::transmute(he_trig_cqi_feedback_disabled) };
            he_trig_cqi_feedback_disabled as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let he_reserved: u32 = unsafe { ::core::mem::transmute(he_reserved) };
            he_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Discovery start configuration"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_config_t {
    #[doc = "< NAN Discovery operating channel"]
    pub op_channel: u8,
    #[doc = "< Device's preference value to serve as NAN Master"]
    pub master_pref: u8,
    #[doc = "< Scan time in seconds while searching for a NAN cluster"]
    pub scan_time: u8,
    #[doc = "< Warm up time before assuming NAN Anchor Master role"]
    pub warm_up_sec: u16,
}
#[doc = " @brief Configuration data for device's AP or STA or NAN."]
#[doc = ""]
#[doc = " The usage of this union (for ap, sta or nan configuration) is determined by the accompanying"]
#[doc = " interface argument passed to esp_wifi_set_config() or esp_wifi_get_config()"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    #[doc = "< configuration of AP"]
    pub ap: wifi_ap_config_t,
    #[doc = "< configuration of STA"]
    pub sta: wifi_sta_config_t,
    #[doc = "< configuration of NAN"]
    pub nan: wifi_nan_config_t,
}
#[doc = " @brief Description of STA associated with AP"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wifi_sta_info_t {
    #[doc = "< mac address"]
    pub mac: [u8; 6usize],
    #[doc = "< current average rssi of sta connected"]
    pub rssi: i8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11ax(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11ax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mesh_child(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mesh_child(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        phy_11ax: u32,
        is_mesh_child: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let phy_11ax: u32 = unsafe { ::core::mem::transmute(phy_11ax) };
            phy_11ax as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_mesh_child: u32 = unsafe { ::core::mem::transmute(is_mesh_child) };
            is_mesh_child as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief List of stations associated with the Soft-AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_list_t {
    #[doc = "< station list"]
    pub sta: [wifi_sta_info_t; 10usize],
    #[doc = "< number of stations in the list (other entries are invalid)"]
    pub num: crate::c_types::c_int,
}
#[doc = "< all configuration will store in both memory and flash"]
pub const wifi_storage_t_WIFI_STORAGE_FLASH: wifi_storage_t = 0;
#[doc = "< all configuration will only store in the memory"]
pub const wifi_storage_t_WIFI_STORAGE_RAM: wifi_storage_t = 1;
pub type wifi_storage_t = crate::c_types::c_uint;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_BEACON: wifi_vendor_ie_type_t = 0;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_REQ: wifi_vendor_ie_type_t = 1;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_RESP: wifi_vendor_ie_type_t = 2;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_REQ: wifi_vendor_ie_type_t = 3;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_RESP: wifi_vendor_ie_type_t = 4;
#[doc = " @brief     Vendor Information Element type"]
#[doc = ""]
#[doc = " Determines the frame type that the IE will be associated with."]
pub type wifi_vendor_ie_type_t = crate::c_types::c_uint;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_0: wifi_vendor_ie_id_t = 0;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_1: wifi_vendor_ie_id_t = 1;
#[doc = " @brief     Vendor Information Element index"]
#[doc = ""]
#[doc = " Each IE type can have up to two associated vendor ID elements."]
pub type wifi_vendor_ie_id_t = crate::c_types::c_uint;
#[doc = "< PHY mode for Low Rate"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_LR: wifi_phy_mode_t = 0;
#[doc = "< PHY mode for 11b"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11B: wifi_phy_mode_t = 1;
#[doc = "< PHY mode for 11g"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_11G: wifi_phy_mode_t = 2;
#[doc = "< PHY mode for Bandwidth HT20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HT20: wifi_phy_mode_t = 3;
#[doc = "< PHY mode for Bandwidth HT40"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HT40: wifi_phy_mode_t = 4;
#[doc = "< PHY mode for Bandwidth HE20"]
pub const wifi_phy_mode_t_WIFI_PHY_MODE_HE20: wifi_phy_mode_t = 5;
#[doc = " @brief     Operation Phymode"]
pub type wifi_phy_mode_t = crate::c_types::c_uint;
#[doc = " @brief Vendor Information Element header"]
#[doc = ""]
#[doc = " The first bytes of the Information Element will match this header. Payload follows."]
#[repr(C)]
pub struct vendor_ie_data_t {
    #[doc = "< Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    pub element_id: u8,
    #[doc = "< Length of all bytes in the element data following this field. Minimum 4."]
    pub length: u8,
    #[doc = "< Vendor identifier (OUI)."]
    pub vendor_oui: [u8; 3usize],
    #[doc = "< Vendor-specific OUI type."]
    pub vendor_oui_type: u8,
    #[doc = "< Payload. Length is equal to value in 'length' field, minus 4."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = " @brief Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> crate::c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: crate::c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary_channel(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondary_channel(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn noise_floor(&self) -> crate::c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(160usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_noise_floor(&mut self, val: crate::c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(160usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ant(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(255usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ant(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(255usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_len(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(352usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sig_len(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(352usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_state(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(376usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_state(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(376usize, 8u8, val as u64)
        }
    }
}
#[doc = " @brief Payload passed to 'buf' parameter of promiscuous mode RX callback."]
#[repr(C)]
pub struct wifi_promiscuous_pkt_t {
    #[doc = "< metadata header"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< Data or management payload. Length of payload is described by rx_ctrl.sig_len. Type of content determined by packet type argument of callback."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Management frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MGMT: wifi_promiscuous_pkt_type_t = 0;
#[doc = "< Control frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_CTRL: wifi_promiscuous_pkt_type_t = 1;
#[doc = "< Data frame, indiciates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_DATA: wifi_promiscuous_pkt_type_t = 2;
#[doc = "< Other type, such as MIMO etc. 'buf' argument is wifi_promiscuous_pkt_t but the payload is zero length."]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MISC: wifi_promiscuous_pkt_type_t = 3;
#[doc = " @brief Promiscuous frame type"]
#[doc = ""]
#[doc = " Passed to promiscuous mode RX callback to indicate the type of parameter in the buffer."]
#[doc = ""]
pub type wifi_promiscuous_pkt_type_t = crate::c_types::c_uint;
#[doc = " @brief Mask for filtering different packet types in promiscuous mode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_promiscuous_filter_t {
    #[doc = "< OR of one or more filter values WIFI_PROMIS_FILTER_*"]
    pub filter_mask: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_csi_config_t {
    #[doc = "< enable to receive legacy long training field(lltf) data. Default enabled"]
    pub lltf_en: bool,
    #[doc = "< enable to receive HT long training field(htltf) data. Default enabled"]
    pub htltf_en: bool,
    #[doc = "< enable to receive space time block code HT long training field(stbc-htltf2) data. Default enabled"]
    pub stbc_htltf2_en: bool,
    #[doc = "< enable to generate htlft data by averaging lltf and ht_ltf data when receiving HT packet. Otherwise, use ht_ltf data directly. Default enabled"]
    pub ltf_merge_en: bool,
    #[doc = "< enable to turn on channel filter to smooth adjacent sub-carrier. Disable it to keep independence of adjacent sub-carrier. Default enabled"]
    pub channel_filter_en: bool,
    #[doc = "< manually scale the CSI data by left shifting or automatically scale the CSI data. If set true, please set the shift bits. false: automatically. true: manually. Default false"]
    pub manu_scale: bool,
    #[doc = "< manually left shift bits of the scale of the CSI data. The range of the left shift bits is 0~15"]
    pub shift: u8,
}
#[doc = " @brief CSI data type"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_csi_info_t {
    #[doc = "< received packet radio metadata header of the CSI data"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< source MAC address of the CSI data"]
    pub mac: [u8; 6usize],
    #[doc = "< destination MAC address of the CSI data"]
    pub dmac: [u8; 6usize],
    #[doc = "< first four bytes of the CSI data is invalid or not"]
    pub first_word_invalid: bool,
    #[doc = "< buffer of CSI data"]
    pub buf: *mut i8,
    #[doc = "< length of CSI data"]
    pub len: u16,
}
#[doc = " @brief WiFi GPIO configuration for antenna selection"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_ant_gpio_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_ant_gpio_t {
    #[inline]
    pub fn gpio_select(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_select(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gpio_select: u8, gpio_num: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpio_select: u8 = unsafe { ::core::mem::transmute(gpio_select) };
            gpio_select as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let gpio_num: u8 = unsafe { ::core::mem::transmute(gpio_num) };
            gpio_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief WiFi GPIOs configuration for antenna selection"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ant_gpio_config_t {
    #[doc = "< The configurations of GPIOs that connect to external antenna switch"]
    pub gpio_cfg: [wifi_ant_gpio_t; 4usize],
}
#[doc = "< Enable WiFi antenna 0 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT0: wifi_ant_mode_t = 0;
#[doc = "< Enable WiFi antenna 1 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT1: wifi_ant_mode_t = 1;
#[doc = "< Enable WiFi antenna 0 and 1, automatically select an antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_AUTO: wifi_ant_mode_t = 2;
#[doc = "< Invalid WiFi enabled antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_MAX: wifi_ant_mode_t = 3;
#[doc = " @brief WiFi antenna mode"]
#[doc = ""]
pub type wifi_ant_mode_t = crate::c_types::c_uint;
#[doc = " @brief WiFi antenna configuration"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ant_config_t {
    #[doc = "< WiFi antenna mode for receiving"]
    pub rx_ant_mode: wifi_ant_mode_t,
    #[doc = "< Default antenna mode for receiving, it's ignored if rx_ant_mode is not WIFI_ANT_MODE_AUTO"]
    pub rx_ant_default: wifi_ant_t,
    #[doc = "< WiFi antenna mode for transmission, it can be set to WIFI_ANT_MODE_AUTO only if rx_ant_mode is set to WIFI_ANT_MODE_AUTO"]
    pub tx_ant_mode: wifi_ant_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_ant_config_t {
    #[inline]
    pub fn enabled_ant0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_ant1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled_ant0: u8,
        enabled_ant1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let enabled_ant0: u8 = unsafe { ::core::mem::transmute(enabled_ant0) };
            enabled_ant0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let enabled_ant1: u8 = unsafe { ::core::mem::transmute(enabled_ant1) };
            enabled_ant1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief     The Rx callback function of Action Tx operations"]
#[doc = ""]
#[doc = " @param     hdr pointer to the IEEE 802.11 Header structure"]
#[doc = " @param     payload pointer to the Payload following 802.11 Header"]
#[doc = " @param     len length of the Payload"]
#[doc = " @param     channel channel number the frame is received on"]
#[doc = ""]
pub type wifi_action_rx_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        hdr: *mut u8,
        payload: *mut u8,
        len: size_t,
        channel: u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Action Frame Tx Request"]
#[doc = ""]
#[doc = ""]
#[repr(C)]
pub struct wifi_action_tx_req_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Destination MAC address"]
    pub dest_mac: [u8; 6usize],
    #[doc = "< Indicates no ack required"]
    pub no_ack: bool,
    #[doc = "< Rx Callback to receive any response"]
    pub rx_cb: wifi_action_rx_cb_t,
    #[doc = "< Length of the appended Data"]
    pub data_len: u32,
    #[doc = "< Appended Data payload"]
    pub data: __IncompleteArrayField<u8>,
}
#[doc = " @brief FTM Initiator configuration"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ftm_initiator_cfg_t {
    #[doc = "< MAC address of the FTM Responder"]
    pub resp_mac: [u8; 6usize],
    #[doc = "< Primary channel of the FTM Responder"]
    pub channel: u8,
    #[doc = "< No. of FTM frames requested in terms of 4 or 8 bursts (allowed values - 0(No pref), 16, 24, 32, 64)"]
    pub frm_count: u8,
    #[doc = "< Requested time period between consecutive FTM bursts in 100's of milliseconds (0 - No pref)"]
    pub burst_period: u16,
}
#[doc = " @brief WiFi beacon monitor parameter configuration"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_beacon_monitor_config_t {
    #[doc = "< Enable or disable beacon monitor"]
    pub enable: bool,
    #[doc = "< Beacon lost timeout"]
    pub loss_timeout: u8,
    #[doc = "< Maximum number of consecutive lost beacons allowed"]
    pub loss_threshold: u8,
    #[doc = "< Delta early time for RF PHY on"]
    pub delta_intr_early: u8,
    #[doc = "< Delta timeout time for RF PHY off"]
    pub delta_loss_timeout: u8,
}
#[doc = "< Send unicast Publish frame to Subscribers that match the requirement"]
pub const wifi_nan_service_type_t_NAN_PUBLISH_SOLICITED: wifi_nan_service_type_t = 0;
#[doc = "< Send broadcast Publish frames in every Discovery Window(DW)"]
pub const wifi_nan_service_type_t_NAN_PUBLISH_UNSOLICITED: wifi_nan_service_type_t = 1;
#[doc = "< Send broadcast Subscribe frames in every DW"]
pub const wifi_nan_service_type_t_NAN_SUBSCRIBE_ACTIVE: wifi_nan_service_type_t = 2;
#[doc = "< Passively listens to Publish frames"]
pub const wifi_nan_service_type_t_NAN_SUBSCRIBE_PASSIVE: wifi_nan_service_type_t = 3;
#[doc = " @brief NAN Services types"]
#[doc = ""]
pub type wifi_nan_service_type_t = crate::c_types::c_uint;
#[doc = " @brief NAN Publish service configuration parameters"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_publish_cfg_t {
    #[doc = "< Service name identifier"]
    pub service_name: [crate::c_types::c_char; 256usize],
    #[doc = "< Service type"]
    pub type_: wifi_nan_service_type_t,
    #[doc = "< Comma separated filters for filtering services"]
    pub matching_filter: [crate::c_types::c_char; 256usize],
    #[doc = "< Service info shared in Publish frame"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_nan_publish_cfg_t {
    #[inline]
    pub fn single_replied_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_replied_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn datapath_reqd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_datapath_reqd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single_replied_event: u8,
        datapath_reqd: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_replied_event: u8 = unsafe { ::core::mem::transmute(single_replied_event) };
            single_replied_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let datapath_reqd: u8 = unsafe { ::core::mem::transmute(datapath_reqd) };
            datapath_reqd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Subscribe service configuration parameters"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_subscribe_cfg_t {
    #[doc = "< Service name identifier"]
    pub service_name: [crate::c_types::c_char; 256usize],
    #[doc = "< Service type"]
    pub type_: wifi_nan_service_type_t,
    #[doc = "< Comma separated filters for filtering services"]
    pub matching_filter: [crate::c_types::c_char; 256usize],
    #[doc = "< Service info shared in Subscribe frame"]
    pub svc_info: [crate::c_types::c_char; 64usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_nan_subscribe_cfg_t {
    #[inline]
    pub fn single_match_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_match_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single_match_event: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_match_event: u8 = unsafe { ::core::mem::transmute(single_match_event) };
            single_match_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief NAN Follow-up parameters"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_followup_params_t {
    #[doc = "< Own service instance id"]
    pub inst_id: u8,
    #[doc = "< Peer's service instance id"]
    pub peer_inst_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< Service info(or message) to be shared"]
    pub svc_info: [crate::c_types::c_char; 64usize],
}
#[doc = " @brief NAN Datapath Request parameters"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_req_t {
    #[doc = "< Publisher's service instance id"]
    pub pub_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< NDP Confirm frame required"]
    pub confirm_required: bool,
}
#[doc = " @brief NAN Datapath Response parameters"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_resp_t {
    #[doc = "< True - Accept incoming NDP, False - Reject it"]
    pub accept: bool,
    #[doc = "< NAN Datapath Identifier"]
    pub ndp_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
}
#[doc = " @brief NAN Datapath End parameters"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_nan_datapath_end_req_t {
    #[doc = "< NAN Datapath Identifier"]
    pub ndp_id: u8,
    #[doc = "< Peer's MAC address"]
    pub peer_mac: [u8; 6usize],
}
#[doc = "< 1 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_1M_L: wifi_phy_rate_t = 0;
#[doc = "< 2 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_L: wifi_phy_rate_t = 1;
#[doc = "< 5.5 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_L: wifi_phy_rate_t = 2;
#[doc = "< 11 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_L: wifi_phy_rate_t = 3;
#[doc = "< 2 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_S: wifi_phy_rate_t = 5;
#[doc = "< 5.5 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_S: wifi_phy_rate_t = 6;
#[doc = "< 11 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_S: wifi_phy_rate_t = 7;
#[doc = "< 48 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_48M: wifi_phy_rate_t = 8;
#[doc = "< 24 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_24M: wifi_phy_rate_t = 9;
#[doc = "< 12 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_12M: wifi_phy_rate_t = 10;
#[doc = "< 6 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_6M: wifi_phy_rate_t = 11;
#[doc = "< 54 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_54M: wifi_phy_rate_t = 12;
#[doc = "< 36 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_36M: wifi_phy_rate_t = 13;
#[doc = "< 18 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_18M: wifi_phy_rate_t = 14;
#[doc = "< 9 Mbps */"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_9M: wifi_phy_rate_t = 15;
#[doc = "< MCS0 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_LGI: wifi_phy_rate_t = 16;
#[doc = "< MCS1 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_LGI: wifi_phy_rate_t = 17;
#[doc = "< MCS2 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_LGI: wifi_phy_rate_t = 18;
#[doc = "< MCS3 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_LGI: wifi_phy_rate_t = 19;
#[doc = "< MCS4 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_LGI: wifi_phy_rate_t = 20;
#[doc = "< MCS5 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_LGI: wifi_phy_rate_t = 21;
#[doc = "< MCS6 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_LGI: wifi_phy_rate_t = 22;
#[doc = "< MCS7 with long GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_LGI: wifi_phy_rate_t = 23;
#[doc = "< MCS0 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_SGI: wifi_phy_rate_t = 24;
#[doc = "< MCS1 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_SGI: wifi_phy_rate_t = 25;
#[doc = "< MCS2 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_SGI: wifi_phy_rate_t = 26;
#[doc = "< MCS3 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_SGI: wifi_phy_rate_t = 27;
#[doc = "< MCS4 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_SGI: wifi_phy_rate_t = 28;
#[doc = "< MCS5 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_SGI: wifi_phy_rate_t = 29;
#[doc = "< MCS6 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_SGI: wifi_phy_rate_t = 30;
#[doc = "< MCS7 with short GI"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_SGI: wifi_phy_rate_t = 31;
#[doc = "< 250 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_250K: wifi_phy_rate_t = 41;
#[doc = "< 500 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_500K: wifi_phy_rate_t = 42;
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MAX: wifi_phy_rate_t = 43;
#[doc = " @brief WiFi PHY rate encodings"]
#[doc = ""]
pub type wifi_phy_rate_t = crate::c_types::c_uint;
#[doc = "< WiFi ready"]
pub const wifi_event_t_WIFI_EVENT_WIFI_READY: wifi_event_t = 0;
#[doc = "< Finished scanning AP"]
pub const wifi_event_t_WIFI_EVENT_SCAN_DONE: wifi_event_t = 1;
#[doc = "< Station start"]
pub const wifi_event_t_WIFI_EVENT_STA_START: wifi_event_t = 2;
#[doc = "< Station stop"]
pub const wifi_event_t_WIFI_EVENT_STA_STOP: wifi_event_t = 3;
#[doc = "< Station connected to AP"]
pub const wifi_event_t_WIFI_EVENT_STA_CONNECTED: wifi_event_t = 4;
#[doc = "< Station disconnected from AP"]
pub const wifi_event_t_WIFI_EVENT_STA_DISCONNECTED: wifi_event_t = 5;
#[doc = "< the auth mode of AP connected by device's station changed"]
pub const wifi_event_t_WIFI_EVENT_STA_AUTHMODE_CHANGE: wifi_event_t = 6;
#[doc = "< Station wps succeeds in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_SUCCESS: wifi_event_t = 7;
#[doc = "< Station wps fails in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_FAILED: wifi_event_t = 8;
#[doc = "< Station wps timeout in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_TIMEOUT: wifi_event_t = 9;
#[doc = "< Station wps pin code in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PIN: wifi_event_t = 10;
#[doc = "< Station wps overlap in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP: wifi_event_t = 11;
#[doc = "< Soft-AP start"]
pub const wifi_event_t_WIFI_EVENT_AP_START: wifi_event_t = 12;
#[doc = "< Soft-AP stop"]
pub const wifi_event_t_WIFI_EVENT_AP_STOP: wifi_event_t = 13;
#[doc = "< a station connected to Soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STACONNECTED: wifi_event_t = 14;
#[doc = "< a station disconnected from Soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STADISCONNECTED: wifi_event_t = 15;
#[doc = "< Receive probe request packet in soft-AP interface"]
pub const wifi_event_t_WIFI_EVENT_AP_PROBEREQRECVED: wifi_event_t = 16;
#[doc = "< Receive report of FTM procedure"]
pub const wifi_event_t_WIFI_EVENT_FTM_REPORT: wifi_event_t = 17;
#[doc = "< AP's RSSI crossed configured threshold"]
pub const wifi_event_t_WIFI_EVENT_STA_BSS_RSSI_LOW: wifi_event_t = 18;
#[doc = "< Status indication of Action Tx operation"]
pub const wifi_event_t_WIFI_EVENT_ACTION_TX_STATUS: wifi_event_t = 19;
#[doc = "< Remain-on-Channel operation complete"]
pub const wifi_event_t_WIFI_EVENT_ROC_DONE: wifi_event_t = 20;
#[doc = "< Station beacon timeout"]
pub const wifi_event_t_WIFI_EVENT_STA_BEACON_TIMEOUT: wifi_event_t = 21;
#[doc = "< Connectionless module wake interval start"]
pub const wifi_event_t_WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START: wifi_event_t = 22;
#[doc = "< Soft-AP wps succeeds in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_SUCCESS: wifi_event_t = 23;
#[doc = "< Soft-AP wps fails in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_FAILED: wifi_event_t = 24;
#[doc = "< Soft-AP wps timeout in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_TIMEOUT: wifi_event_t = 25;
#[doc = "< Soft-AP wps pin code in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PIN: wifi_event_t = 26;
#[doc = "< Soft-AP wps overlap in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PBC_OVERLAP: wifi_event_t = 27;
#[doc = "< iTWT setup"]
pub const wifi_event_t_WIFI_EVENT_ITWT_SETUP: wifi_event_t = 28;
#[doc = "< iTWT teardown"]
pub const wifi_event_t_WIFI_EVENT_ITWT_TEARDOWN: wifi_event_t = 29;
#[doc = "< iTWT probe"]
pub const wifi_event_t_WIFI_EVENT_ITWT_PROBE: wifi_event_t = 30;
#[doc = "< iTWT suspend"]
pub const wifi_event_t_WIFI_EVENT_ITWT_SUSPEND: wifi_event_t = 31;
#[doc = "< NAN Discovery has started"]
pub const wifi_event_t_WIFI_EVENT_NAN_STARTED: wifi_event_t = 32;
#[doc = "< NAN Discovery has stopped"]
pub const wifi_event_t_WIFI_EVENT_NAN_STOPPED: wifi_event_t = 33;
#[doc = "< NAN Service Discovery match found"]
pub const wifi_event_t_WIFI_EVENT_NAN_SVC_MATCH: wifi_event_t = 34;
#[doc = "< Replied to a NAN peer with Service Discovery match"]
pub const wifi_event_t_WIFI_EVENT_NAN_REPLIED: wifi_event_t = 35;
#[doc = "< Received a Follow-up message"]
pub const wifi_event_t_WIFI_EVENT_NAN_RECEIVE: wifi_event_t = 36;
#[doc = "< Received NDP Request from a NAN Peer"]
pub const wifi_event_t_WIFI_EVENT_NDP_INDICATION: wifi_event_t = 37;
#[doc = "< NDP Confirm Indication"]
pub const wifi_event_t_WIFI_EVENT_NDP_CONFIRM: wifi_event_t = 38;
#[doc = "< NAN Datapath terminated indication"]
pub const wifi_event_t_WIFI_EVENT_NDP_TERMINATED: wifi_event_t = 39;
#[doc = "< Invalid WiFi event ID"]
pub const wifi_event_t_WIFI_EVENT_MAX: wifi_event_t = 40;
#[doc = " WiFi event declarations"]
pub type wifi_event_t = crate::c_types::c_uint;
extern "C" {
    pub static WIFI_EVENT: esp_event_base_t;
}
#[doc = " Argument structure for WIFI_EVENT_SCAN_DONE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_scan_done_t {
    #[doc = "< status of scanning APs: 0 — success, 1 - failure"]
    pub status: u32,
    #[doc = "< number of scan results"]
    pub number: u8,
    #[doc = "< scan sequence number, used for block scan"]
    pub scan_id: u8,
}
#[doc = " Argument structure for WIFI_EVENT_STA_CONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_connected_t {
    #[doc = "< SSID of connected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of connected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of connected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of connected AP"]
    pub channel: u8,
    #[doc = "< authentication mode used by AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< authentication id assigned by the connected AP"]
    pub aid: u16,
}
#[doc = " Argument structure for WIFI_EVENT_STA_DISCONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_disconnected_t {
    #[doc = "< SSID of disconnected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of disconnected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of disconnected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< reason of disconnection"]
    pub reason: u8,
    #[doc = "< rssi of disconnection"]
    pub rssi: i8,
}
#[doc = " Argument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_authmode_change_t {
    #[doc = "< the old auth mode of AP"]
    pub old_mode: wifi_auth_mode_t,
    #[doc = "< the new auth mode of AP"]
    pub new_mode: wifi_auth_mode_t,
}
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_PIN event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< WPS normal fail reason"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_NORMAL:
    wifi_event_sta_wps_fail_reason_t = 0;
#[doc = "< WPS receive M2D frame"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_M2D:
    wifi_event_sta_wps_fail_reason_t = 1;
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_MAX: wifi_event_sta_wps_fail_reason_t =
    2;
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_FAILED event"]
pub type wifi_event_sta_wps_fail_reason_t = crate::c_types::c_uint;
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_SUCCESS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t {
    #[doc = "< Number of AP credentials received"]
    pub ap_cred_cnt: u8,
    #[doc = "< All AP credentials received from WPS handshake"]
    pub ap_cred: [wifi_event_sta_wps_er_success_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t__bindgen_ty_1 {
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< Passphrase for the AP"]
    pub passphrase: [u8; 64usize],
}
#[doc = " Argument structure for WIFI_EVENT_AP_STACONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_staconnected_t {
    #[doc = "< MAC address of the station connected to Soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that soft-AP gives to the station connected to"]
    pub aid: u8,
    #[doc = "< flag to identify mesh child"]
    pub is_mesh_child: bool,
}
#[doc = " Argument structure for WIFI_EVENT_AP_STADISCONNECTED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_stadisconnected_t {
    #[doc = "< MAC address of the station disconnects to soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that soft-AP gave to the station disconnects to"]
    pub aid: u8,
    #[doc = "< flag to identify mesh child"]
    pub is_mesh_child: bool,
}
#[doc = " Argument structure for WIFI_EVENT_AP_PROBEREQRECVED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_probe_req_rx_t {
    #[doc = "< Received probe request signal strength"]
    pub rssi: crate::c_types::c_int,
    #[doc = "< MAC address of the station which send probe request"]
    pub mac: [u8; 6usize],
}
#[doc = " Argument structure for WIFI_EVENT_STA_BSS_RSSI_LOW event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_bss_rssi_low_t {
    #[doc = "< RSSI value of bss"]
    pub rssi: i32,
}
#[doc = "< FTM exchange is successful"]
pub const wifi_ftm_status_t_FTM_STATUS_SUCCESS: wifi_ftm_status_t = 0;
#[doc = "< Peer does not support FTM"]
pub const wifi_ftm_status_t_FTM_STATUS_UNSUPPORTED: wifi_ftm_status_t = 1;
#[doc = "< Peer rejected FTM configuration in FTM Request"]
pub const wifi_ftm_status_t_FTM_STATUS_CONF_REJECTED: wifi_ftm_status_t = 2;
#[doc = "< Peer did not respond to FTM Requests"]
pub const wifi_ftm_status_t_FTM_STATUS_NO_RESPONSE: wifi_ftm_status_t = 3;
#[doc = "< Unknown error during FTM exchange"]
pub const wifi_ftm_status_t_FTM_STATUS_FAIL: wifi_ftm_status_t = 4;
#[doc = " @brief FTM operation status types"]
#[doc = ""]
pub type wifi_ftm_status_t = crate::c_types::c_uint;
#[doc = " Argument structure for"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ftm_report_entry_t {
    #[doc = "< Dialog Token of the FTM frame"]
    pub dlog_token: u8,
    #[doc = "< RSSI of the FTM frame received"]
    pub rssi: i8,
    #[doc = "< Round Trip Time in pSec with a peer"]
    pub rtt: u32,
    #[doc = "< Time of departure of FTM frame from FTM Responder in pSec"]
    pub t1: u64,
    #[doc = "< Time of arrival of FTM frame at FTM Initiator in pSec"]
    pub t2: u64,
    #[doc = "< Time of departure of ACK from FTM Initiator in pSec"]
    pub t3: u64,
    #[doc = "< Time of arrival of ACK at FTM Responder in pSec"]
    pub t4: u64,
}
#[doc = " Argument structure for WIFI_EVENT_FTM_REPORT event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ftm_report_t {
    #[doc = "< MAC address of the FTM Peer"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< Status of the FTM operation"]
    pub status: wifi_ftm_status_t,
    #[doc = "< Raw average Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_raw: u32,
    #[doc = "< Estimated Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_est: u32,
    #[doc = "< Estimated one-way distance in Centi-Meters"]
    pub dist_est: u32,
    #[doc = "< Pointer to FTM Report with multiple entries, should be freed after use"]
    pub ftm_report_data: *mut wifi_ftm_report_entry_t,
    #[doc = "< Number of entries in the FTM Report data"]
    pub ftm_report_num_entries: u8,
}
#[doc = " Argument structure for WIFI_EVENT_ACTION_TX_STATUS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_action_tx_status_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Context to identify the request"]
    pub context: u32,
    #[doc = "< Destination MAC address"]
    pub da: [u8; 6usize],
    #[doc = "< Status of the operation"]
    pub status: u8,
}
#[doc = " Argument structure for WIFI_EVENT_ROC_DONE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_roc_done_t {
    #[doc = "< Context to identify the request"]
    pub context: u32,
}
#[doc = " Argument structure for WIFI_EVENT_AP_WPS_RG_PIN event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< WPS normal fail reason"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_NORMAL: wps_fail_reason_t = 0;
#[doc = "< WPS failed due to incorrect config"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_CONFIG: wps_fail_reason_t = 1;
#[doc = "< WPS failed during auth"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_AUTH: wps_fail_reason_t = 2;
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_MAX: wps_fail_reason_t = 3;
pub type wps_fail_reason_t = crate::c_types::c_uint;
#[doc = " Argument structure for WIFI_EVENT_AP_WPS_RG_FAILED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_fail_reason_t {
    #[doc = "< WPS failure reason wps_fail_reason_t"]
    pub reason: wps_fail_reason_t,
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
#[doc = " Argument structure for WIFI_EVENT_AP_WPS_RG_SUCCESS event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ap_wps_rg_success_t {
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
#[doc = " Argument structure for WIFI_EVENT_NAN_SVC_MATCH event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_nan_svc_match_t {
    #[doc = "< Subscribe Service Identifier"]
    pub subscribe_id: u8,
    #[doc = "< Publish Service Identifier"]
    pub publish_id: u8,
    #[doc = "< NAN Interface MAC of the Publisher"]
    pub pub_if_mac: [u8; 6usize],
}
#[doc = " Argument structure for WIFI_EVENT_NAN_REPLIED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_nan_replied_t {
    #[doc = "< Publish Service Identifier"]
    pub publish_id: u8,
    #[doc = "< Subscribe Service Identifier"]
    pub subscribe_id: u8,
    #[doc = "< NAN Interface MAC of the Subscriber"]
    pub sub_if_mac: [u8; 6usize],
}
#[doc = " Argument structure for WIFI_EVENT_NAN_RECEIVE event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_nan_receive_t {
    #[doc = "< Our Service Identifier"]
    pub inst_id: u8,
    #[doc = "< Peer's Service Identifier"]
    pub peer_inst_id: u8,
    #[doc = "< Peer's NAN Interface MAC"]
    pub peer_if_mac: [u8; 6usize],
    #[doc = "< Peer Service Info"]
    pub peer_svc_info: [u8; 64usize],
}
#[doc = " Argument structure for WIFI_EVENT_NDP_INDICATION event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ndp_indication_t {
    #[doc = "< Publish Id for NAN Service"]
    pub publish_id: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Peer's NAN Management Interface MAC"]
    pub peer_nmi: [u8; 6usize],
    #[doc = "< Peer's NAN Data Interface MAC"]
    pub peer_ndi: [u8; 6usize],
    #[doc = "< Service Specific Info"]
    pub svc_info: [u8; 64usize],
}
#[doc = " Argument structure for WIFI_EVENT_NDP_CONFIRM event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ndp_confirm_t {
    #[doc = "< NDP status code"]
    pub status: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Peer's NAN Management Interface MAC"]
    pub peer_nmi: [u8; 6usize],
    #[doc = "< Peer's NAN Data Interface MAC"]
    pub peer_ndi: [u8; 6usize],
    #[doc = "< Own NAN Data Interface MAC"]
    pub own_ndi: [u8; 6usize],
    #[doc = "< Service Specific Info"]
    pub svc_info: [u8; 64usize],
}
#[doc = " Argument structure for WIFI_EVENT_NDP_TERMINATED event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_event_ndp_terminated_t {
    #[doc = "< Termination reason code"]
    pub reason: u8,
    #[doc = "< NDP instance id"]
    pub ndp_id: u8,
    #[doc = "< Initiator's NAN Data Interface MAC"]
    pub init_ndi: [u8; 6usize],
}
#[doc = " Configuration for creating event loops"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_event_loop_args_t {
    #[doc = "< size of the event loop queue"]
    pub queue_size: i32,
    #[doc = "< name of the event loop task; if NULL,"]
    #[doc = "a dedicated task is not created for event loop"]
    pub task_name: *const crate::c_types::c_char,
    #[doc = "< priority of the event loop task, ignored if task name is NULL"]
    pub task_priority: UBaseType_t,
    #[doc = "< stack size of the event loop task, ignored if task name is NULL"]
    pub task_stack_size: u32,
    #[doc = "< core to which the event loop task is pinned to,"]
    #[doc = "ignored if task name is NULL"]
    pub task_core_id: BaseType_t,
}
extern "C" {
    #[doc = " @brief Create a new event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_loop_args configuration structure for the event loop to create"]
    #[doc = " @param[out] event_loop handle to the created event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_INVALID_ARG: event_loop_args or event_loop was NULL"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - ESP_FAIL: Failed to create task loop"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_create(
        event_loop_args: *const esp_event_loop_args_t,
        event_loop: *mut esp_event_loop_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an existing event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_loop event loop to delete, must not be NULL"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_delete(event_loop: esp_event_loop_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create default event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - ESP_FAIL: Failed to create task loop"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_create_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the default event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_delete_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dispatch events posted to an event loop."]
    #[doc = ""]
    #[doc = " This function is used to dispatch events posted to a loop with no dedicated task, i.e. task name was set to NULL"]
    #[doc = " in event_loop_args argument during loop creation. This function includes an argument to limit the amount of time"]
    #[doc = " it runs, returning control to the caller when that time expires (or some time afterwards). There is no guarantee"]
    #[doc = " that a call to this function will exit at exactly the time of expiry. There is also no guarantee that events have"]
    #[doc = " been dispatched during the call, as the function might have spent all the allotted time waiting on the event queue."]
    #[doc = " Once an event has been dequeued, however, it is guaranteed to be dispatched. This guarantee contributes to not being"]
    #[doc = " able to exit exactly at time of expiry as (1) blocking on internal mutexes is necessary for dispatching the dequeued"]
    #[doc = " event, and (2) during  dispatch of the dequeued event there is no way to control the time occupied by handler code"]
    #[doc = " execution. The guaranteed time of exit is therefore the allotted time + amount of time required to dispatch"]
    #[doc = " the last dequeued event."]
    #[doc = ""]
    #[doc = " In cases where waiting on the queue times out, ESP_OK is returned and not ESP_ERR_TIMEOUT, since it is"]
    #[doc = " normal behavior."]
    #[doc = ""]
    #[doc = " @param[in] event_loop event loop to dispatch posted events from, must not be NULL"]
    #[doc = " @param[in] ticks_to_run number of ticks to run the loop"]
    #[doc = ""]
    #[doc = " @note encountering an unknown event that has been posted to the loop will only generate a warning, not an error."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_run(
        event_loop: esp_event_loop_handle_t,
        ticks_to_run: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to the system event loop (legacy)."]
    #[doc = ""]
    #[doc = " This function can be used to register a handler for either: (1) specific events,"]
    #[doc = " (2) all events of a certain event base, or (3) all events known by the system event loop."]
    #[doc = ""]
    #[doc = "  - specific events: specify exact event_base and event_id"]
    #[doc = "  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id"]
    #[doc = "  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id"]
    #[doc = ""]
    #[doc = " Registering multiple handlers to events is possible. Registering a single handler to multiple events is"]
    #[doc = " also possible. However, registering the same handler to the same event multiple times would cause the"]
    #[doc = " previous registrations to be overwritten."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base ID of the event to register the handler for"]
    #[doc = " @param[in] event_id the ID of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to a specific loop (legacy)."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_handler_register, except the additional"]
    #[doc = " specification of the event loop to register the handler to."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to register this handler function to, must not be NULL"]
    #[doc = " @param[in] event_base the base ID of the event to register the handler for"]
    #[doc = " @param[in] event_id the ID of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to a specific loop."]
    #[doc = ""]
    #[doc = " This function can be used to register a handler for either: (1) specific events,"]
    #[doc = " (2) all events of a certain event base, or (3) all events known by the system event loop."]
    #[doc = ""]
    #[doc = "  - specific events: specify exact event_base and event_id"]
    #[doc = "  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id"]
    #[doc = "  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id"]
    #[doc = ""]
    #[doc = " Besides the error, the function returns an instance object as output parameter to identify each registration."]
    #[doc = " This is necessary to remove (unregister) the registration before the event loop is deleted."]
    #[doc = ""]
    #[doc = " Registering multiple handlers to events, registering a single handler to multiple events as well as registering"]
    #[doc = " the same handler to the same event multiple times is possible."]
    #[doc = " Each registration yields a distinct instance object which identifies it over the registration"]
    #[doc = " lifetime."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to register this handler function to, must not be NULL"]
    #[doc = " @param[in] event_base the base ID of the event to register the handler for"]
    #[doc = " @param[in] event_id the ID of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = " @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL."]
    #[doc = "             This needs to be kept if the specific callback instance should be unregistered before deleting the whole"]
    #[doc = "             event loop. Registering the same event handler multiple times is possible and yields distinct instance"]
    #[doc = "             objects. The data can be the same for all registrations."]
    #[doc = "             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,"]
    #[doc = "             instance can be NULL."]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_instance_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to the default loop."]
    #[doc = ""]
    #[doc = " This function does the same as esp_event_handler_instance_register_with, except that it registers the"]
    #[doc = " handler to the default event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base ID of the event to register the handler for"]
    #[doc = " @param[in] event_id the ID of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = " @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL."]
    #[doc = "             This needs to be kept if the specific callback instance should be unregistered before deleting the whole"]
    #[doc = "             event loop. Registering the same event handler multiple times is possible and yields distinct instance"]
    #[doc = "             objects. The data can be the same for all registrations."]
    #[doc = "             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,"]
    #[doc = "             instance can be NULL."]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_instance_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut crate::c_types::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop (legacy)."]
    #[doc = ""]
    #[doc = " Unregisters a handler, so it will no longer be called during dispatch."]
    #[doc = " Handlers can be unregistered for any combination of event_base and event_id which were previously registered."]
    #[doc = " To unregister a handler, the event_base and event_id arguments must match exactly the arguments passed to"]
    #[doc = " esp_event_handler_register() when that handler was registered. Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID"]
    #[doc = " will only unregister handlers that were registered with the same wildcard arguments."]
    #[doc = ""]
    #[doc = " @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be"]
    #[doc = "       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be"]
    #[doc = "       unregistered. This avoids accidental unregistration of handlers registered by other users or components."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the ID of the event with which to unregister the handler"]
    #[doc = " @param[in] event_handler the handler to unregister"]
    #[doc = ""]
    #[doc = " @return ESP_OK success"]
    #[doc = " @return ESP_ERR_INVALID_ARG invalid combination of event base and event ID"]
    #[doc = " @return others fail"]
    pub fn esp_event_handler_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from a specific event loop (legacy)."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_handler_unregister, except the additional specification of"]
    #[doc = " the event loop to unregister the handler with."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL"]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the ID of the event with which to unregister the handler"]
    #[doc = " @param[in] event_handler the handler to unregister"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler instance from a specific event loop."]
    #[doc = ""]
    #[doc = " Unregisters a handler instance, so it will no longer be called during dispatch."]
    #[doc = " Handler instances can be unregistered for any combination of event_base and event_id which were previously"]
    #[doc = " registered. To unregister a handler instance, the event_base and event_id arguments must match exactly the"]
    #[doc = " arguments passed to esp_event_handler_instance_register() when that handler instance was registered."]
    #[doc = " Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID will only unregister handler instances that were registered"]
    #[doc = " with the same wildcard arguments."]
    #[doc = ""]
    #[doc = " @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be"]
    #[doc = "       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be"]
    #[doc = "       unregistered. This avoids accidental unregistration of handlers registered by other users or components."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL"]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the ID of the event with which to unregister the handler"]
    #[doc = " @param[in] instance the instance object of the registration to be unregistered"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from the system event loop."]
    #[doc = ""]
    #[doc = " This function does the same as esp_event_handler_instance_unregister_with, except that it unregisters the"]
    #[doc = " handler instance from the default event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the ID of the event with which to unregister the handler"]
    #[doc = " @param[in] instance the instance object of the registration to be unregistered"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the system default event loop. The event loop library keeps a copy of event_data and manages"]
    #[doc = " the copy's lifetime automatically (allocation + deletion); this ensures that the data the"]
    #[doc = " handler receives is always valid."]
    #[doc = ""]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the event ID that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[in] ticks_to_wait number of ticks to block on a full event queue"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,"]
    #[doc = "                      queue full when posting from ISR"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the specified event loop. The event loop library keeps a copy of event_data and manages"]
    #[doc = " the copy's lifetime automatically (allocation + deletion); this ensures that the data the"]
    #[doc = " handler receives is always valid."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_post_to, except the additional specification of the event loop"]
    #[doc = " to post the event to."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to post to, must not be NULL"]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the event ID that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[in] ticks_to_wait number of ticks to block on a full event queue"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,"]
    #[doc = "                      queue full when posting from ISR"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Special variant of esp_event_post for posting events from interrupt handlers."]
    #[doc = ""]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the event ID that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data; max is 4 bytes"]
    #[doc = " @param[out] task_unblocked an optional parameter (can be NULL) which indicates that an event task with"]
    #[doc = "                            higher priority than currently running task has been unblocked by the posted event;"]
    #[doc = "                            a context switch should be requested before the interrupt is existed."]
    #[doc = ""]
    #[doc = " @note this function is only available when CONFIG_ESP_EVENT_POST_FROM_ISR is enabled"]
    #[doc = " @note when this function is called from an interrupt handler placed in IRAM, this function should"]
    #[doc = "       be placed in IRAM as well by enabling CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_FAIL: Event queue for the default event loop full"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID,"]
    #[doc = "                          data size of more than 4 bytes"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_isr_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: size_t,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Special variant of esp_event_post_to for posting events from interrupt handlers"]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to post to, must not be NULL"]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the event ID that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[out] task_unblocked an optional parameter (can be NULL) which indicates that an event task with"]
    #[doc = "                            higher priority than currently running task has been unblocked by the posted event;"]
    #[doc = "                            a context switch should be requested before the interrupt is existed."]
    #[doc = ""]
    #[doc = " @note this function is only available when CONFIG_ESP_EVENT_POST_FROM_ISR is enabled"]
    #[doc = " @note when this function is called from an interrupt handler placed in IRAM, this function should"]
    #[doc = "       be placed in IRAM as well by enabling CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_FAIL: Event queue for the loop full"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID,"]
    #[doc = "                          data size of more than 4 bytes"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_isr_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const crate::c_types::c_void,
        event_data_size: size_t,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dumps statistics of all event loops."]
    #[doc = ""]
    #[doc = " Dumps event loop info in the format:"]
    #[doc = ""]
    #[doc = "@verbatim"]
    #[doc = "event loop"]
    #[doc = "handler"]
    #[doc = "handler"]
    #[doc = "..."]
    #[doc = "event loop"]
    #[doc = "handler"]
    #[doc = "handler"]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "where:"]
    #[doc = ""]
    #[doc = "event loop"]
    #[doc = "format: address,name rx:total_received dr:total_dropped"]
    #[doc = "where:"]
    #[doc = "address - memory address of the event loop"]
    #[doc = "name - name of the event loop, 'none' if no dedicated task"]
    #[doc = "total_received - number of successfully posted events"]
    #[doc = "total_dropped - number of events unsuccessfully posted due to queue being full"]
    #[doc = ""]
    #[doc = "handler"]
    #[doc = "format: address ev:base,id inv:total_invoked run:total_runtime"]
    #[doc = "where:"]
    #[doc = "address - address of the handler function"]
    #[doc = "base,id - the event specified by event base and ID this handler executes"]
    #[doc = "total_invoked - number of times this handler has been invoked"]
    #[doc = "total_runtime - total amount of time used for invoking this handler"]
    #[doc = ""]
    #[doc = "@endverbatim"]
    #[doc = ""]
    #[doc = " @param[in] file the file stream to output to"]
    #[doc = ""]
    #[doc = " @note this function is a noop when CONFIG_ESP_EVENT_LOOP_PROFILING is disabled"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_dump(file: *mut FILE) -> esp_err_t;
}
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_MD5: esp_crypto_hash_alg_t = 0;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA1: esp_crypto_hash_alg_t = 1;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_MD5: esp_crypto_hash_alg_t = 2;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA1: esp_crypto_hash_alg_t = 3;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA256: esp_crypto_hash_alg_t = 4;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA256: esp_crypto_hash_alg_t = 5;
pub type esp_crypto_hash_alg_t = crate::c_types::c_uint;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_NULL: esp_crypto_cipher_alg_t = 0;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_AES: esp_crypto_cipher_alg_t = 1;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_3DES: esp_crypto_cipher_alg_t = 2;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_DES: esp_crypto_cipher_alg_t = 3;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC2: esp_crypto_cipher_alg_t = 4;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC4: esp_crypto_cipher_alg_t = 5;
pub type esp_crypto_cipher_alg_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_hash {
    _unused: [u8; 0],
}
pub type esp_crypto_hash_t = crypto_hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_cipher {
    _unused: [u8; 0],
}
pub type esp_crypto_cipher_t = crypto_cipher;
#[doc = " @brief The AES callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Encryption key."]
#[doc = " @param iv  Encryption IV for CBC mode (16 bytes)."]
#[doc = " @param data  Data to encrypt in-place."]
#[doc = " @param data_len  Length of data in bytes (must be divisible by 16)"]
pub type esp_aes_128_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        iv: *const crate::c_types::c_uchar,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Decryption key."]
#[doc = " @param iv  Decryption IV for CBC mode (16 bytes)."]
#[doc = " @param data  Data to decrypt in-place."]
#[doc = " @param data_len  Length of data in bytes (must be divisible by 16)"]
#[doc = ""]
pub type esp_aes_128_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        iv: *const crate::c_types::c_uchar,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param kek  16-octet Key encryption key (KEK)."]
#[doc = " @param n  Length of the plaintext key in 64-bit units;"]
#[doc = " @param plain  Plaintext key to be wrapped, n * 64 bits"]
#[doc = " @param cipher  Wrapped key, (n + 1) * 64 bits"]
#[doc = ""]
pub type esp_aes_wrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const crate::c_types::c_uchar,
        n: crate::c_types::c_int,
        plain: *const crate::c_types::c_uchar,
        cipher: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param kek  16-octet Key decryption key (KEK)."]
#[doc = " @param n  Length of the plaintext key in 64-bit units;"]
#[doc = " @param cipher  Wrapped key to be unwrapped, (n + 1) * 64 bits"]
#[doc = " @param plain  Plaintext key, n * 64 bits"]
#[doc = ""]
pub type esp_aes_unwrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const crate::c_types::c_uchar,
        n: crate::c_types::c_int,
        cipher: *const crate::c_types::c_uchar,
        plain: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The SHA256 callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Key for HMAC operations."]
#[doc = " @param key_len  Length of the key in bytes."]
#[doc = " @param num_elem  Number of elements in the data vector."]
#[doc = " @param addr  Pointers to the data areas."]
#[doc = " @param len  Lengths of the data blocks."]
#[doc = " @param mac  Buffer for the hash (32 bytes)."]
#[doc = ""]
pub type esp_hmac_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_int,
        num_elem: crate::c_types::c_int,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_int,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param key  Key for PRF."]
#[doc = " @param key_len  Length of the key in bytes."]
#[doc = " @param label  A unique label for each purpose of the PRF."]
#[doc = " @param data  Extra data to bind into the key."]
#[doc = " @param data_len  Length of the data."]
#[doc = " @param buf  Buffer for the generated pseudo-random key."]
#[doc = " @param buf_len  Number of bytes of key to generate."]
#[doc = ""]
pub type esp_sha256_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_int,
        label: *const crate::c_types::c_char,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_int,
        buf: *mut crate::c_types::c_uchar,
        buf_len: crate::c_types::c_int,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 over data buffer (RFC 2104)'"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @data: Pointers to the data area"]
#[doc = " @data_len: Length of the data area"]
#[doc = " @mac: Buffer for the hash (16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 over data vector (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash (16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data buffer (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @data: Pointers to the data area"]
#[doc = " @data_len: Length of the data area"]
#[doc = " @mac: Buffer for the hash (20 bytes)"]
#[doc = " Returns: 0 on success, -1 of failure"]
pub type esp_hmac_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data vector (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash (20 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1)"]
#[doc = ""]
#[doc = " @key: Key for PRF"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @label: A unique label for each purpose of the PRF"]
#[doc = " @data: Extra data to bind into the key"]
#[doc = " @data_len: Length of the data"]
#[doc = " @buf: Buffer for the generated pseudo-random key"]
#[doc = " @buf_len: Number of bytes of key to generate"]
#[doc = " Returns: 0 on success, -1 of failure"]
#[doc = ""]
#[doc = " This function is used to derive new, cryptographically separate keys from a"]
#[doc = " given key (e.g., PMK in IEEE 802.11i)."]
pub type esp_sha1_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        key_len: crate::c_types::c_uint,
        label: *const crate::c_types::c_char,
        data: *const crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
        buf: *mut crate::c_types::c_uchar,
        buf_len: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA-1 hash for data vector"]
#[doc = ""]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA1-based key derivation function (PBKDF2) for IEEE 802.11i"]
#[doc = ""]
#[doc = " @passphrase: ASCII passphrase"]
#[doc = " @ssid: SSID"]
#[doc = " @ssid_len: SSID length in bytes"]
#[doc = " @iterations: Number of iterations to run"]
#[doc = " @buf: Buffer for the generated key"]
#[doc = " @buflen: Length of the buffer in bytes"]
#[doc = " Returns: 0 on success, -1 of failure"]
#[doc = ""]
#[doc = " This function is used to derive PSK for WPA-PSK. For this protocol,"]
#[doc = " iterations is set to 4096 and buflen to 32. This function is described in"]
#[doc = " IEEE Std 802.11-2004, Clause H.4. The main construction is from PKCS#5 v2.0."]
pub type esp_pbkdf2_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        passphrase: *const crate::c_types::c_char,
        ssid: *const crate::c_types::c_char,
        ssid_len: crate::c_types::c_uint,
        iterations: crate::c_types::c_int,
        buf: *mut crate::c_types::c_uchar,
        buflen: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief XOR RC4 stream to given data with skip-stream-start"]
#[doc = ""]
#[doc = " @key: RC4 key"]
#[doc = " @keylen: RC4 key length"]
#[doc = " @skip: number of bytes to skip from the beginning of the RC4 stream"]
#[doc = " @data: data to be XOR'ed with RC4 stream"]
#[doc = " @data_len: buf length"]
#[doc = " Returns: 0 on success, -1 on failure"]
#[doc = ""]
#[doc = " Generate RC4 pseudo random stream for the given key, skip beginning of the"]
#[doc = " stream, and XOR the end result with the data buffer to perform RC4"]
#[doc = " encryption/decryption."]
pub type esp_rc4_skip_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        keylen: crate::c_types::c_uint,
        skip: crate::c_types::c_uint,
        data: *mut crate::c_types::c_uchar,
        data_len: crate::c_types::c_uint,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief MD5 hash for data vector"]
#[doc = ""]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: crate::c_types::c_uint,
        addr: *mut *const crate::c_types::c_uchar,
        len: *const crate::c_types::c_uint,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Encrypt one AES block"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
#[doc = " @plain: Plaintext data to be encrypted (16 bytes)"]
#[doc = " @crypt: Buffer for the encrypted data (16 bytes)"]
pub type esp_aes_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        plain: *const crate::c_types::c_uchar,
        crypt: *mut crate::c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for encryption"]
#[doc = ""]
#[doc = " @key: Encryption key"]
#[doc = " @len: Key length in bytes (usually 16, i.e., 128 bits)"]
#[doc = " Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_encrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        len: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void,
>;
#[doc = " @brief Deinitialize AES encryption"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_encrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void)>;
#[doc = " @brief Decrypt one AES block"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
#[doc = " @crypt: Encrypted data (16 bytes)"]
#[doc = " @plain: Buffer for the decrypted data (16 bytes)"]
pub type esp_aes_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        crypt: *const crate::c_types::c_uchar,
        plain: *mut crate::c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for decryption"]
#[doc = ""]
#[doc = " @key: Decryption key"]
#[doc = " @len: Key length in bytes (usually 16, i.e., 128 bits)"]
#[doc = " Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_decrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const crate::c_types::c_uchar,
        len: crate::c_types::c_uint,
    ) -> *mut crate::c_types::c_void,
>;
#[doc = " @brief Deinitialize AES decryption"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_decrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void)>;
#[doc = " @brief One-Key CBC MAC (OMAC1) hash with AES-128 for MIC computation"]
#[doc = ""]
#[doc = " @key: 128-bit key for the hash operation"]
#[doc = " @data: Data buffer for which a MIC is computed"]
#[doc = " @data_len: Length of data buffer in bytes"]
#[doc = " @mic: Buffer for MIC (128 bits, i.e., 16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_omac1_aes_128_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        data: *const u8,
        data_len: size_t,
        mic: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief Decrypt data using CCMP (Counter Mode CBC-MAC Protocol OR"]
#[doc = "        Counter Mode Cipher Block Chaining Message Authentication"]
#[doc = "        Code Protocol) which is used in IEEE 802.11i RSN standard."]
#[doc = " @tk: 128-bit Temporal Key for obtained during 4-way handshake"]
#[doc = " @hdr: Pointer to IEEE802.11 frame headeri needed for AAD"]
#[doc = " @data: Pointer to encrypted data buffer"]
#[doc = " @data_len: Encrypted data length in bytes"]
#[doc = " @decrypted_len: Length of decrypted data"]
#[doc = " @espnow_pkt: Indicates if it's an ESPNOW packet"]
#[doc = " Returns: Pointer to decrypted data on success, NULL on failure"]
pub type esp_ccmp_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        ieee80211_hdr: *const u8,
        data: *const u8,
        data_len: size_t,
        decrypted_len: *mut size_t,
        espnow_pkt: bool,
    ) -> *mut u8,
>;
#[doc = " @brief Encrypt data using CCMP (Counter Mode CBC-MAC Protocol OR"]
#[doc = "        Counter Mode Cipher Block Chaining Message Authentication"]
#[doc = "        Code Protocol) which is used in IEEE 802.11i RSN standard."]
#[doc = " @tk: 128-bit Temporal Key for obtained during 4-way handshake"]
#[doc = " @frame: Pointer to IEEE802.11 frame including header"]
#[doc = " @len: Length of the frame including header"]
#[doc = " @hdrlen: Length of the header"]
#[doc = " @pn: Packet Number counter"]
#[doc = " @keyid: Key ID to be mentioned in CCMP Vector"]
#[doc = " @encrypted_len: Length of the encrypted frame including header"]
pub type esp_ccmp_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        frame: *mut u8,
        len: size_t,
        hdrlen: size_t,
        pn: *mut u8,
        keyid: crate::c_types::c_int,
        encrypted_len: *mut size_t,
    ) -> *mut u8,
>;
#[doc = " @brief One-Key GMAC hash with AES for MIC computation"]
#[doc = ""]
#[doc = " @key: key for the hash operation"]
#[doc = " @keylen: key length"]
#[doc = " @iv: initialization vector"]
#[doc = " @iv_len: initialization vector length"]
#[doc = " @aad: aad"]
#[doc = " @aad_len: aad length"]
#[doc = " @mic: Buffer for MIC (128 bits, i.e., 16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_aes_gmac_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        keylen: size_t,
        iv: *const u8,
        iv_len: size_t,
        aad: *const u8,
        aad_len: size_t,
        mic: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief SHA256 hash for data vector"]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: size_t,
        addr: *mut *const u8,
        len: *const size_t,
        buf: *mut u8,
    ) -> crate::c_types::c_int,
>;
#[doc = " @brief CRC32 value in little endian."]
#[doc = ""]
#[doc = " @param crc: Initial CRC value (result of last calculation or 0 for the first time)"]
#[doc = " @param buf: Data buffer that used to calculate the CRC value"]
#[doc = " @param len: Length of the data buffer"]
#[doc = " @return CRC32 value"]
pub type esp_crc32_le_t =
    ::core::option::Option<unsafe extern "C" fn(crc: u32, buf: *const u8, len: u32) -> u32>;
#[doc = " @brief The crypto callback function structure used when do station security connect."]
#[doc = "        The structure can be set as software crypto or the crypto optimized by device's"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wpa_crypto_funcs_t {
    pub size: u32,
    pub version: u32,
    #[doc = "< station connect function used when send EAPOL frame"]
    pub aes_wrap: esp_aes_wrap_t,
    #[doc = "< station connect function used when decrypt key data"]
    pub aes_unwrap: esp_aes_unwrap_t,
    #[doc = "< station connect function used when check MIC"]
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    #[doc = "< station connect function used when check MIC"]
    pub sha256_prf: esp_sha256_prf_t,
    pub hmac_md5: esp_hmac_md5_t,
    pub hamc_md5_vector: esp_hmac_md5_vector_t,
    pub hmac_sha1: esp_hmac_sha1_t,
    pub hmac_sha1_vector: esp_hmac_sha1_vector_t,
    pub sha1_prf: esp_sha1_prf_t,
    pub sha1_vector: esp_sha1_vector_t,
    pub pbkdf2_sha1: esp_pbkdf2_sha1_t,
    pub rc4_skip: esp_rc4_skip_t,
    pub md5_vector: esp_md5_vector_t,
    pub aes_encrypt: esp_aes_encrypt_t,
    pub aes_encrypt_init: esp_aes_encrypt_init_t,
    pub aes_encrypt_deinit: esp_aes_encrypt_deinit_t,
    pub aes_decrypt: esp_aes_decrypt_t,
    pub aes_decrypt_init: esp_aes_decrypt_init_t,
    pub aes_decrypt_deinit: esp_aes_decrypt_deinit_t,
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
    pub omac1_aes_128: esp_omac1_aes_128_t,
    pub ccmp_decrypt: esp_ccmp_decrypt_t,
    pub ccmp_encrypt: esp_ccmp_encrypt_t,
    pub aes_gmac: esp_aes_gmac_t,
    pub sha256_vector: esp_sha256_vector_t,
    pub crc32: esp_crc32_le_t,
}
#[doc = " @brief The crypto callback function structure used in mesh vendor IE encryption. The"]
#[doc = "        structure can be set as software crypto or the crypto optimized by device's"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mesh_crypto_funcs_t {
    #[doc = "< function used in mesh vendor IE encryption"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< function used in mesh vendor IE decryption"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_osi_funcs_t {
    pub _version: i32,
    pub _env_is_chip: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _set_intr: ::core::option::Option<
        unsafe extern "C" fn(cpu_no: i32, intr_source: u32, intr_num: u32, intr_prio: i32),
    >,
    pub _clear_intr: ::core::option::Option<unsafe extern "C" fn(intr_source: u32, intr_num: u32)>,
    pub _set_isr: ::core::option::Option<
        unsafe extern "C" fn(
            n: i32,
            f: *mut crate::c_types::c_void,
            arg: *mut crate::c_types::c_void,
        ),
    >,
    pub _ints_on: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _ints_off: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _is_from_isr: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _spin_lock_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _spin_lock_delete:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut crate::c_types::c_void)>,
    pub _wifi_int_disable: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut crate::c_types::c_void) -> u32,
    >,
    pub _wifi_int_restore: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut crate::c_types::c_void, tmp: u32),
    >,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut crate::c_types::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void)>,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::c_types::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void) -> i32>,
    pub _wifi_thread_semphr_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _recursive_mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _mutex_delete:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void)>,
    pub _mutex_lock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void) -> i32>,
    pub _mutex_unlock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::c_types::c_void) -> i32>,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut crate::c_types::c_void,
    >,
    pub _queue_delete:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void)>,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            hptw: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _queue_send_to_back: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_to_front: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::c_types::c_void,
            item: *mut crate::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_msg_waiting:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void) -> u32>,
    pub _event_group_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _event_group_delete:
        ::core::option::Option<unsafe extern "C" fn(event: *mut crate::c_types::c_void)>,
    pub _event_group_set_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut crate::c_types::c_void, bits: u32) -> u32,
    >,
    pub _event_group_clear_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut crate::c_types::c_void, bits: u32) -> u32,
    >,
    pub _event_group_wait_bits: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut crate::c_types::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: crate::c_types::c_int,
            wait_for_all_bits: crate::c_types::c_int,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _task_create_pinned_to_core: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut crate::c_types::c_void,
            name: *const crate::c_types::c_char,
            stack_depth: u32,
            param: *mut crate::c_types::c_void,
            prio: u32,
            task_handle: *mut crate::c_types::c_void,
            core_id: u32,
        ) -> i32,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut crate::c_types::c_void,
            name: *const crate::c_types::c_char,
            stack_depth: u32,
            param: *mut crate::c_types::c_void,
            prio: u32,
            task_handle: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _task_delete:
        ::core::option::Option<unsafe extern "C" fn(task_handle: *mut crate::c_types::c_void)>,
    pub _task_delay: ::core::option::Option<unsafe extern "C" fn(tick: u32)>,
    pub _task_ms_to_tick: ::core::option::Option<unsafe extern "C" fn(ms: u32) -> i32>,
    pub _task_get_current_task:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _task_get_max_priority: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut crate::c_types::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut crate::c_types::c_void)>,
    pub _event_post: ::core::option::Option<
        unsafe extern "C" fn(
            event_base: *const crate::c_types::c_char,
            event_id: i32,
            event_data: *mut crate::c_types::c_void,
            event_data_size: size_t,
            ticks_to_wait: u32,
        ) -> i32,
    >,
    pub _get_free_heap_size: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _rand: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _dport_access_stall_other_cpu_start_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _dport_access_stall_other_cpu_end_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_request: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_release: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_update_country_info: ::core::option::Option<
        unsafe extern "C" fn(country: *const crate::c_types::c_char) -> crate::c_types::c_int,
    >,
    pub _read_mac: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut u8, type_: crate::c_types::c_uint) -> crate::c_types::c_int,
    >,
    pub _timer_arm: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut crate::c_types::c_void, tmout: u32, repeat: bool),
    >,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut crate::c_types::c_void)>,
    pub _timer_done:
        ::core::option::Option<unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut crate::c_types::c_void,
            pfunction: *mut crate::c_types::c_void,
            parg: *mut crate::c_types::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void, us: u32, repeat: bool),
    >,
    pub _wifi_reset_mac: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_enable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_disable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _nvs_set_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: i8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut i8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_set_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: u8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut u8,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_set_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: u16,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut u16,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_open: ::core::option::Option<
        unsafe extern "C" fn(
            name: *const crate::c_types::c_char,
            open_mode: crate::c_types::c_uint,
            out_handle: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_close: ::core::option::Option<unsafe extern "C" fn(handle: u32)>,
    pub _nvs_commit:
        ::core::option::Option<unsafe extern "C" fn(handle: u32) -> crate::c_types::c_int>,
    pub _nvs_set_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            value: *const crate::c_types::c_void,
            length: size_t,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_get_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
            out_value: *mut crate::c_types::c_void,
            length: *mut size_t,
        ) -> crate::c_types::c_int,
    >,
    pub _nvs_erase_key: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const crate::c_types::c_char,
        ) -> crate::c_types::c_int,
    >,
    pub _get_random: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut u8, len: size_t) -> crate::c_types::c_int,
    >,
    pub _get_time: ::core::option::Option<
        unsafe extern "C" fn(t: *mut crate::c_types::c_void) -> crate::c_types::c_int,
    >,
    pub _random: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_ulong>,
    pub _slowclk_cal_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(
            level: crate::c_types::c_uint,
            tag: *const crate::c_types::c_char,
            format: *const crate::c_types::c_char,
            ...
        ),
    >,
    pub _log_writev: ::core::option::Option<
        unsafe extern "C" fn(
            level: crate::c_types::c_uint,
            tag: *const crate::c_types::c_char,
            format: *const crate::c_types::c_char,
            args: va_list,
        ),
    >,
    pub _log_timestamp: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut crate::c_types::c_void>,
    pub _realloc_internal: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut crate::c_types::c_void,
            size: size_t,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _calloc_internal: ::core::option::Option<
        unsafe extern "C" fn(n: size_t, size: size_t) -> *mut crate::c_types::c_void,
    >,
    pub _zalloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut crate::c_types::c_void>,
    pub _wifi_malloc:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut crate::c_types::c_void>,
    pub _wifi_realloc: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut crate::c_types::c_void,
            size: size_t,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_calloc: ::core::option::Option<
        unsafe extern "C" fn(n: size_t, size: size_t) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_zalloc:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut crate::c_types::c_void>,
    pub _wifi_create_queue: ::core::option::Option<
        unsafe extern "C" fn(
            queue_len: crate::c_types::c_int,
            item_size: crate::c_types::c_int,
        ) -> *mut crate::c_types::c_void,
    >,
    pub _wifi_delete_queue:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::c_types::c_void)>,
    pub _coex_init: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_deinit: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_enable: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_status_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_condition_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, dissatisfy: bool)>,
    pub _coex_wifi_request: ::core::option::Option<
        unsafe extern "C" fn(event: u32, latency: u32, duration: u32) -> crate::c_types::c_int,
    >,
    pub _coex_wifi_release:
        ::core::option::Option<unsafe extern "C" fn(event: u32) -> crate::c_types::c_int>,
    pub _coex_wifi_channel_set: ::core::option::Option<
        unsafe extern "C" fn(primary: u8, secondary: u8) -> crate::c_types::c_int,
    >,
    pub _coex_event_duration_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, duration: *mut u32) -> crate::c_types::c_int,
    >,
    pub _coex_pti_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, pti: *mut u8) -> crate::c_types::c_int,
    >,
    pub _coex_schm_status_bit_clear:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_status_bit_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_interval_set:
        ::core::option::Option<unsafe extern "C" fn(interval: u32) -> crate::c_types::c_int>,
    pub _coex_schm_interval_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_schm_curr_period_get: ::core::option::Option<unsafe extern "C" fn() -> u8>,
    pub _coex_schm_curr_phase_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::c_types::c_void>,
    pub _coex_schm_process_restart:
        ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _coex_schm_register_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: crate::c_types::c_int,
            cb: ::core::option::Option<
                unsafe extern "C" fn(arg1: crate::c_types::c_int) -> crate::c_types::c_int,
            >,
        ) -> crate::c_types::c_int,
    >,
    pub _coex_register_start_cb: ::core::option::Option<
        unsafe extern "C" fn(
            cb: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
        ) -> crate::c_types::c_int,
    >,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_wifi_osi_funcs: wifi_osi_funcs_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi station interface to supplied netif"]
    #[doc = ""]
    #[doc = " @param esp_netif instance to attach the wifi station to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success"]
    #[doc = "  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_station(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi soft AP interface to supplied netif"]
    #[doc = ""]
    #[doc = " @param esp_netif instance to attach the wifi AP to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success"]
    #[doc = "  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_ap(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for STA interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_sta_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for AP interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_ap_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for NAN interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_nan_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clears default wifi event handlers for supplied network interface"]
    #[doc = ""]
    #[doc = " @param esp_netif instance of corresponding if object"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_clear_default_wifi_driver_and_handlers(
        esp_netif: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI AP. In case of any init error this API aborts."]
    #[doc = ""]
    #[doc = " @note The API creates esp_netif object with default WiFi access point config,"]
    #[doc = " attaches the netif to wifi and registers default wifi handlers."]
    #[doc = ""]
    #[doc = " @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_ap() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI STA. In case of any init error this API aborts."]
    #[doc = ""]
    #[doc = " @note The API creates esp_netif object with default WiFi station config,"]
    #[doc = " attaches the netif to wifi and registers default wifi handlers."]
    #[doc = ""]
    #[doc = " @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_sta() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI NAN. In case of any init error this API aborts."]
    #[doc = ""]
    #[doc = " @note The API creates esp_netif object with default WiFi station config,"]
    #[doc = " attaches the netif to wifi and registers default wifi handlers."]
    #[doc = ""]
    #[doc = " @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_nan() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Destroys default WIFI netif created with esp_netif_create_default_wifi_...() API."]
    #[doc = ""]
    #[doc = " @param[in] esp_netif object to detach from WiFi and destroy"]
    #[doc = ""]
    #[doc = " @note This API unregisters wifi handlers and detaches the created object from the wifi."]
    #[doc = " (this function is a no-operation if esp_netif is NULL)"]
    pub fn esp_netif_destroy_default_wifi(esp_netif: *mut crate::c_types::c_void);
}
extern "C" {
    #[doc = " @brief Creates esp_netif WiFi object based on the custom configuration."]
    #[doc = ""]
    #[doc = " @attention This API DOES NOT register default handlers!"]
    #[doc = ""]
    #[doc = " @param[in] wifi_if type of wifi interface"]
    #[doc = " @param[in] esp_netif_config inherent esp-netif configuration pointer"]
    #[doc = ""]
    #[doc = " @return pointer to esp-netif instance"]
    pub fn esp_netif_create_wifi(
        wifi_if: wifi_interface_t,
        esp_netif_config: *const esp_netif_inherent_config_t,
    ) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default STA and AP network interfaces for esp-mesh."]
    #[doc = ""]
    #[doc = " Both netifs are almost identical to the default station and softAP, but with"]
    #[doc = " DHCP client and server disabled. Please note that the DHCP client is typically"]
    #[doc = " enabled only if the device is promoted to a root node."]
    #[doc = ""]
    #[doc = " Returns created interfaces which could be ignored setting parameters to NULL"]
    #[doc = " if an application code does not need to save the interface instances"]
    #[doc = " for further processing."]
    #[doc = ""]
    #[doc = " @param[out] p_netif_sta pointer where the resultant STA interface is saved (if non NULL)"]
    #[doc = " @param[out] p_netif_ap pointer where the resultant AP interface is saved (if non NULL)"]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_netif_create_default_wifi_mesh_netifs(
        p_netif_sta: *mut *mut esp_netif_t,
        p_netif_ap: *mut *mut esp_netif_t,
    ) -> esp_err_t;
}
#[doc = " @brief WiFi stack configuration parameters passed to esp_wifi_init call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_init_config_t {
    #[doc = "< WiFi OS functions"]
    pub osi_funcs: *mut wifi_osi_funcs_t,
    #[doc = "< WiFi station crypto functions when connect"]
    pub wpa_crypto_funcs: wpa_crypto_funcs_t,
    #[doc = "< WiFi static RX buffer number"]
    pub static_rx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi dynamic RX buffer number"]
    pub dynamic_rx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi TX buffer type"]
    pub tx_buf_type: crate::c_types::c_int,
    #[doc = "< WiFi static TX buffer number"]
    pub static_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi dynamic TX buffer number"]
    pub dynamic_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi TX cache buffer number"]
    pub cache_tx_buf_num: crate::c_types::c_int,
    #[doc = "< WiFi channel state information enable flag"]
    pub csi_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMPDU RX feature enable flag"]
    pub ampdu_rx_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMPDU TX feature enable flag"]
    pub ampdu_tx_enable: crate::c_types::c_int,
    #[doc = "< WiFi AMSDU TX feature enable flag"]
    pub amsdu_tx_enable: crate::c_types::c_int,
    #[doc = "< WiFi NVS flash enable flag"]
    pub nvs_enable: crate::c_types::c_int,
    #[doc = "< Nano option for printf/scan family enable flag"]
    pub nano_enable: crate::c_types::c_int,
    #[doc = "< WiFi Block Ack RX window size"]
    pub rx_ba_win: crate::c_types::c_int,
    #[doc = "< WiFi Task Core ID"]
    pub wifi_task_core_id: crate::c_types::c_int,
    #[doc = "< WiFi softAP maximum length of the beacon"]
    pub beacon_max_len: crate::c_types::c_int,
    #[doc = "< WiFi management short buffer number, the minimum value is 6, the maximum value is 32"]
    pub mgmt_sbuf_num: crate::c_types::c_int,
    #[doc = "< Enables additional WiFi features and capabilities"]
    pub feature_caps: u64,
    #[doc = "< WiFi Power Management for station at disconnected status"]
    pub sta_disconnected_pm: bool,
    #[doc = "< Maximum encrypt number of peers supported by espnow"]
    pub espnow_max_encrypt_num: crate::c_types::c_int,
    #[doc = "< WiFi init magic number, it should be the last field"]
    pub magic: crate::c_types::c_int,
}
extern "C" {
    #[doc = " @addtogroup WPA_APIs"]
    #[doc = " @{"]
    pub static g_wifi_default_wpa_crypto_funcs: wpa_crypto_funcs_t;
}
extern "C" {
    pub static mut g_wifi_feature_caps: u64;
}
extern "C" {
    #[doc = " @brief  Initialize WiFi"]
    #[doc = "         Allocate resource for WiFi driver, such as WiFi control structure, RX/TX buffer,"]
    #[doc = "         WiFi NVS structure etc. This WiFi also starts WiFi task"]
    #[doc = ""]
    #[doc = " @attention 1. This API must be called before all other WiFi API can be called"]
    #[doc = " @attention 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to initialize the configuration to default values, this can"]
    #[doc = "               guarantee all the fields get correct value when more fields are added into wifi_init_config_t"]
    #[doc = "               in future release. If you want to set your own initial values, overwrite the default values"]
    #[doc = "               which are set by WIFI_INIT_CONFIG_DEFAULT. Please be notified that the field 'magic' of"]
    #[doc = "               wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC!"]
    #[doc = ""]
    #[doc = " @param  config pointer to WiFi initialized configuration structure; can point to a temporary variable."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinit WiFi"]
    #[doc = "         Free all resource allocated in esp_wifi_init and stop WiFi task"]
    #[doc = ""]
    #[doc = " @attention 1. This API should be called if you want to remove WiFi driver from the system"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi operating mode"]
    #[doc = ""]
    #[doc = "            Set the WiFi operating mode as station, soft-AP, station+soft-AP or NAN."]
    #[doc = "            The default mode is station mode."]
    #[doc = ""]
    #[doc = " @param     mode  WiFi operating mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_mode(mode: wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get current operating mode of WiFi"]
    #[doc = ""]
    #[doc = " @param[out]  mode  store current WiFi mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_mode(mode: *mut wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start WiFi according to current configuration"]
    #[doc = "         If mode is WIFI_MODE_STA, it creates station control block and starts station"]
    #[doc = "         If mode is WIFI_MODE_AP, it creates soft-AP control block and starts soft-AP"]
    #[doc = "         If mode is WIFI_MODE_APSTA, it creates soft-AP and station control block and starts soft-AP and station"]
    #[doc = "         If mode is WIFI_MODE_NAN, it creates NAN control block and starts NAN"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong"]
    #[doc = "    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop WiFi"]
    #[doc = "         If mode is WIFI_MODE_STA, it stops station and frees station control block"]
    #[doc = "         If mode is WIFI_MODE_AP, it stops soft-AP and frees soft-AP control block"]
    #[doc = "         If mode is WIFI_MODE_APSTA, it stops station/soft-AP and frees station/soft-AP control block"]
    #[doc = "         If mode is WIFI_MODE_NAN, it stops NAN and frees NAN control block"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restore WiFi stack persistent settings to default values"]
    #[doc = ""]
    #[doc = " This function will reset settings made using the following APIs:"]
    #[doc = " - esp_wifi_set_bandwidth,"]
    #[doc = " - esp_wifi_set_protocol,"]
    #[doc = " - esp_wifi_set_config related"]
    #[doc = " - esp_wifi_set_mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_restore() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect WiFi station to the AP."]
    #[doc = ""]
    #[doc = " @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode"]
    #[doc = " @attention 2. If station interface is connected to an AP, call esp_wifi_disconnect to disconnect."]
    #[doc = " @attention 3. The scanning triggered by esp_wifi_scan_start() will not be effective until connection between device and the AP is established."]
    #[doc = "               If device is scanning and connecting at the same time, it will abort scanning and return a warning message and error"]
    #[doc = "               number ESP_ERR_WIFI_STATE."]
    #[doc = "               If you want to do reconnection after device received disconnect event, remember to add the maximum retry time, otherwise the called"]
    #[doc = "               scan will not work. This is especially true when the AP doesn't exist, and you still try reconnection after device received disconnect"]
    #[doc = "               event with the reason code WIFI_REASON_NO_AP_FOUND."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong"]
    #[doc = "    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect WiFi station from the AP."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_disconnect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Currently this API is just an stub API"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: fail"]
    pub fn esp_wifi_clear_fast_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     deauthenticate all stations or associated id equals to aid"]
    #[doc = ""]
    #[doc = " @param     aid  when aid is 0, deauthenticate all stations, otherwise deauthenticate station whose associated id is aid"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    pub fn esp_wifi_deauth_sta(aid: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Scan all available APs."]
    #[doc = ""]
    #[doc = " @attention If this API is called, the found APs are stored in WiFi driver dynamic allocated memory and the"]
    #[doc = "            will be freed in esp_wifi_scan_get_ap_records, so generally, call esp_wifi_scan_get_ap_records to cause"]
    #[doc = "            the memory to be freed once the scan is done"]
    #[doc = " @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds."]
    #[doc = "            Values above 1500ms may cause station to disconnect from AP and are not recommended."]
    #[doc = ""]
    #[doc = " @param     config  configuration of scanning"]
    #[doc = " @param     block if block is true, this API will block the caller until the scan is done, otherwise"]
    #[doc = "                         it will return immediately"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_TIMEOUT: blocking scan is timeout"]
    #[doc = "    - ESP_ERR_WIFI_STATE: wifi still connecting when invoke esp_wifi_scan_start"]
    #[doc = "    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_scan_start(config: *const wifi_scan_config_t, block: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop the scan in process"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_scan_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get number of APs found in last scan"]
    #[doc = ""]
    #[doc = " @param[out] number  store number of APIs found in last scan"]
    #[doc = ""]
    #[doc = " @attention This API can only be called when the scan is completed, otherwise it may get wrong value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_scan_get_ap_num(number: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AP list found in last scan"]
    #[doc = ""]
    #[doc = " @param[inout]  number As input param, it stores max AP number ap_records can hold."]
    #[doc = "                As output param, it receives the actual AP number this API returns."]
    #[doc = " @param         ap_records  wifi_ap_record_t array to hold the found APs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    pub fn esp_wifi_scan_get_ap_records(
        number: *mut u16,
        ap_records: *mut wifi_ap_record_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Clear AP list found in last scan"]
    #[doc = ""]
    #[doc = " @attention When the obtained ap list fails,bss info must be cleared,otherwise it may cause memory leakage."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_clear_ap_list() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get information of AP to which the device is associated with"]
    #[doc = ""]
    #[doc = " @attention When the obtained country information is empty, it means that the AP does not carry country information"]
    #[doc = ""]
    #[doc = " @param     ap_info  the wifi_ap_record_t to hold AP information"]
    #[doc = "            sta can get the connected ap's phy mode info through the struct member"]
    #[doc = "            phy_11b，phy_11g，phy_11n，phy_lr in the wifi_ap_record_t struct."]
    #[doc = "            For example, phy_11b = 1 imply that ap support 802.11b mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_CONN: The station interface don't initialized"]
    #[doc = "    - ESP_ERR_WIFI_NOT_CONNECT: The station is in disconnect status"]
    pub fn esp_wifi_sta_get_ap_info(ap_info: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi power save type"]
    #[doc = ""]
    #[doc = " @attention Default power save type is WIFI_PS_MIN_MODEM."]
    #[doc = ""]
    #[doc = " @param     type  power save type"]
    #[doc = ""]
    #[doc = " @return    ESP_OK: succeed"]
    pub fn esp_wifi_set_ps(type_: wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi power save type"]
    #[doc = ""]
    #[doc = " @attention Default power save type is WIFI_PS_MIN_MODEM."]
    #[doc = ""]
    #[doc = " @param[out]  type: store current power save type"]
    #[doc = ""]
    #[doc = " @return    ESP_OK: succeed"]
    pub fn esp_wifi_get_ps(type_: *mut wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of specified interface"]
    #[doc = "            The default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)."]
    #[doc = "            if CONFIG_SOC_WIFI_HE_SUPPORT, the default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AX)."]
    #[doc = ""]
    #[doc = " @attention Support 802.11b or 802.11bg or 802.11bgn or 802.11bgnax or LR mode"]
    #[doc = ""]
    #[doc = " @param     ifx  interfaces"]
    #[doc = " @param     protocol_bitmap  WiFi protocol bitmap"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_protocol(ifx: wifi_interface_t, protocol_bitmap: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the current protocol bitmap of the specified interface"]
    #[doc = ""]
    #[doc = " @param     ifx  interface"]
    #[doc = " @param[out] protocol_bitmap  store current WiFi protocol bitmap of interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_get_protocol(ifx: wifi_interface_t, protocol_bitmap: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the bandwidth of specified interface"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to configure an interface that is not enabled"]
    #[doc = " @attention 2. WIFI_BW_HT40 is supported only when the interface support 11N"]
    #[doc = ""]
    #[doc = " @param     ifx  interface to be configured"]
    #[doc = " @param     bw  bandwidth"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_bandwidth(ifx: wifi_interface_t, bw: wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the bandwidth of specified interface"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to get a interface that is not enable"]
    #[doc = ""]
    #[doc = " @param     ifx interface to be configured"]
    #[doc = " @param[out] bw  store bandwidth of interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_bandwidth(ifx: wifi_interface_t, bw: *mut wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set primary/secondary channel of device"]
    #[doc = ""]
    #[doc = " @attention 1. This API should be called after esp_wifi_start()"]
    #[doc = " @attention 2. When device is in STA mode, this API should not be called when STA is scanning or connecting to an external AP"]
    #[doc = " @attention 3. When device is in softAP mode, this API should not be called when softAP has connected to external STAs"]
    #[doc = " @attention 4. When device is in STA+softAP mode, this API should not be called when in the scenarios described above"]
    #[doc = " @attention 5. The channel info set by this API will not be stored in NVS. So If you want to remeber the channel used before wifi stop,"]
    #[doc = "               you need to call this API again after wifi start, or you can call `esp_wifi_set_config()` to store the channel info in NVS."]
    #[doc = ""]
    #[doc = " @param     primary  for HT20, primary is the channel number, for HT40, primary is the primary channel"]
    #[doc = " @param     second   for HT20, second is ignored, for HT40, second is the second channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_channel(primary: u8, second: wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the primary/secondary channel of device"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to get a interface that is not enable"]
    #[doc = ""]
    #[doc = " @param     primary   store current primary channel"]
    #[doc = " @param[out]  second  store current second channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_channel(primary: *mut u8, second: *mut wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country info"]
    #[doc = ""]
    #[doc = " @attention 1. It is discouraged to call this API since this doesn't validate the per-country rules,"]
    #[doc = "               it's up to the user to fill in all fields according to local regulations."]
    #[doc = "               Please use esp_wifi_set_country_code instead."]
    #[doc = " @attention 2. The default country is \"01\" (world safe mode) {.cc=\"01\", .schan=1, .nchan=11, .policy=WIFI_COUNTRY_POLICY_AUTO}."]
    #[doc = " @attention 3. The third octect of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '."]
    #[doc = " @attention 4. When the country policy is WIFI_COUNTRY_POLICY_AUTO, the country info of the AP to which"]
    #[doc = "               the station is connected is used. E.g. if the configured country info is {.cc=\"US\", .schan=1, .nchan=11}"]
    #[doc = "               and the country info of the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}"]
    #[doc = "               then the country info that will be used is {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected"]
    #[doc = "               from the AP the country info is set back to the country info of the station automatically,"]
    #[doc = "               {.cc=\"US\", .schan=1, .nchan=11} in the example."]
    #[doc = " @attention 5. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, then the configured country info is used always."]
    #[doc = " @attention 6. When the country info is changed because of configuration or because the station connects to a different"]
    #[doc = "               external AP, the country IE in probe response/beacon of the soft-AP is also changed."]
    #[doc = " @attention 7. The country configuration is stored into flash."]
    #[doc = " @attention 8. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the"]
    #[doc = "               country info."]
    #[doc = ""]
    #[doc = " @param     country   the configured country info"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country(country: *const wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country info"]
    #[doc = ""]
    #[doc = " @param     country  country info"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country(country: *mut wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set MAC address of WiFi station, soft-AP or NAN interface."]
    #[doc = ""]
    #[doc = " @attention 1. This API can only be called when the interface is disabled"]
    #[doc = " @attention 2. Above mentioned interfaces have different MAC addresses, do not set them to be the same."]
    #[doc = " @attention 3. The bit 0 of the first byte of MAC address can not be 1. For example, the MAC address"]
    #[doc = "      can set to be \"1a:XX:XX:XX:XX:XX\", but can not be \"15:XX:XX:XX:XX:XX\"."]
    #[doc = ""]
    #[doc = " @param     ifx  interface"]
    #[doc = " @param     mac  the MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_WIFI_MAC: invalid mac address"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_mac(ifx: wifi_interface_t, mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mac of specified interface"]
    #[doc = ""]
    #[doc = " @param      ifx  interface"]
    #[doc = " @param[out] mac  store mac of the interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_mac(ifx: wifi_interface_t, mac: *mut u8) -> esp_err_t;
}
#[doc = " @brief The RX callback function in the promiscuous mode."]
#[doc = "        Each time a packet is received, the callback function will be called."]
#[doc = ""]
#[doc = " @param buf  Data received. Type of data in buffer (wifi_promiscuous_pkt_t or wifi_pkt_rx_ctrl_t) indicated by 'type' parameter."]
#[doc = " @param type  promiscuous packet type."]
#[doc = ""]
pub type wifi_promiscuous_cb_t = ::core::option::Option<
    unsafe extern "C" fn(buf: *mut crate::c_types::c_void, type_: wifi_promiscuous_pkt_type_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function in the promiscuous mode."]
    #[doc = ""]
    #[doc = " Each time a packet is received, the registered callback function will be called."]
    #[doc = ""]
    #[doc = " @param cb  callback"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Enable the promiscuous mode."]
    #[doc = ""]
    #[doc = " @param     en  false - disable, true - enable"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[out] en  store the current status of promiscuous mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous(en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the promiscuous mode packet type filter."]
    #[doc = ""]
    #[doc = " @note The default filter is to filter all packets except WIFI_PKT_MISC"]
    #[doc = ""]
    #[doc = " @param filter the packet type filtered in promiscuous mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_filter(filter: *const wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous filter."]
    #[doc = ""]
    #[doc = " @param[out] filter  store the current status of promiscuous filter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_filter(filter: *mut wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable subtype filter of the control packet in promiscuous mode."]
    #[doc = ""]
    #[doc = " @note The default filter is to filter none control packet."]
    #[doc = ""]
    #[doc = " @param filter the subtype of the control packet filtered in promiscuous mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_ctrl_filter(
        filter: *const wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the subtype filter of the control packet in promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[out] filter  store the current status of subtype filter of the control packet in promiscuous mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_ctrl_filter(
        filter: *mut wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the configuration of the STA, AP or NAN"]
    #[doc = ""]
    #[doc = " @attention 1. This API can be called only when specified interface is enabled, otherwise, API fail"]
    #[doc = " @attention 2. For station configuration, bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    #[doc = " @attention 3. ESP devices are limited to only one channel, so when in the soft-AP+station mode, the soft-AP will adjust its channel automatically to be the same as"]
    #[doc = "               the channel of the station."]
    #[doc = " @attention 4. The configuration will be stored in NVS for station and soft-AP"]
    #[doc = ""]
    #[doc = " @param     interface  interface"]
    #[doc = " @param     conf  station, soft-AP or NAN configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_WIFI_MODE: invalid mode"]
    #[doc = "    - ESP_ERR_WIFI_PASSWORD: invalid password"]
    #[doc = "    - ESP_ERR_WIFI_NVS: WiFi internal NVS error"]
    #[doc = "    - others: refer to the erro code in esp_err.h"]
    pub fn esp_wifi_set_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get configuration of specified interface"]
    #[doc = ""]
    #[doc = " @param     interface  interface"]
    #[doc = " @param[out]  conf  station or soft-AP configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get STAs associated with soft-AP"]
    #[doc = ""]
    #[doc = " @attention SSC only API"]
    #[doc = ""]
    #[doc = " @param[out] sta  station list"]
    #[doc = "             ap can get the connected sta's phy mode info through the struct member"]
    #[doc = "             phy_11b，phy_11g，phy_11n，phy_lr in the wifi_sta_info_t struct."]
    #[doc = "             For example, phy_11b = 1 imply that sta support 802.11b mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_list(sta: *mut wifi_sta_list_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AID of STA connected with soft-AP"]
    #[doc = ""]
    #[doc = " @param     mac  STA's mac address"]
    #[doc = " @param[out]  aid  Store the AID corresponding to STA mac"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NOT_FOUND: Requested resource not found"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_aid(mac: *const u8, aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi API configuration storage type"]
    #[doc = ""]
    #[doc = " @attention 1. The default value is WIFI_STORAGE_FLASH"]
    #[doc = ""]
    #[doc = " @param     storage : storage type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - ESP_OK: succeed"]
    #[doc = "   - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "   - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_storage(storage: wifi_storage_t) -> esp_err_t;
}
#[doc = " @brief     Function signature for received Vendor-Specific Information Element callback."]
#[doc = " @param     ctx Context argument, as passed to esp_wifi_set_vendor_ie_cb() when registering callback."]
#[doc = " @param     type Information element type, based on frame type received."]
#[doc = " @param     sa Source 802.11 address."]
#[doc = " @param     vnd_ie Pointer to the vendor specific element data received."]
#[doc = " @param     rssi Received signal strength indication."]
pub type esp_vendor_ie_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        type_: wifi_vendor_ie_type_t,
        sa: *const u8,
        vnd_ie: *const vendor_ie_data_t,
        rssi: crate::c_types::c_int,
    ),
>;
extern "C" {
    #[doc = " @brief     Set 802.11 Vendor-Specific Information Element"]
    #[doc = ""]
    #[doc = " @param     enable If true, specified IE is enabled. If false, specified IE is removed."]
    #[doc = " @param     type Information Element type. Determines the frame type to associate with the IE."]
    #[doc = " @param     idx  Index to set or clear. Each IE type can be associated with up to two elements (indices 0 & 1)."]
    #[doc = " @param     vnd_ie Pointer to vendor specific element data. First 6 bytes should be a header with fields matching vendor_ie_data_t."]
    #[doc = "            If enable is false, this argument is ignored and can be NULL. Data does not need to remain valid after the function returns."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init()"]
    #[doc = "    - ESP_ERR_INVALID_ARG: Invalid argument, including if first byte of vnd_ie is not WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    #[doc = "      or second byte is an invalid length."]
    #[doc = "    - ESP_ERR_NO_MEM: Out of memory"]
    pub fn esp_wifi_set_vendor_ie(
        enable: bool,
        type_: wifi_vendor_ie_type_t,
        idx: wifi_vendor_ie_id_t,
        vnd_ie: *const crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register Vendor-Specific Information Element monitoring callback."]
    #[doc = ""]
    #[doc = " @param     cb   Callback function"]
    #[doc = " @param     ctx  Context argument, passed to callback function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_vendor_ie_cb(
        cb: esp_vendor_ie_cb_t,
        ctx: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set maximum transmitting power after WiFi start."]
    #[doc = ""]
    #[doc = " @attention 1. Maximum power before wifi startup is limited by PHY init data bin."]
    #[doc = " @attention 2. The value set by this API will be mapped to the max_tx_power of the structure wifi_country_t variable."]
    #[doc = " @attention 3. Mapping Table {Power, max_tx_power} = {{8,   2}, {20,  5}, {28,  7}, {34,  8}, {44, 11},"]
    #[doc = "                                                      {52, 13}, {56, 14}, {60, 15}, {66, 16}, {72, 18}, {80, 20}}."]
    #[doc = " @attention 4. Param power unit is 0.25dBm, range is [8, 84] corresponding to 2dBm - 20dBm."]
    #[doc = " @attention 5. Relationship between set value and actual value. As follows: {set value range, actual value} = {{[8,  19],8}, {[20, 27],20}, {[28, 33],28}, {[34, 43],34}, {[44, 51],44}, {[52, 55],52}, {[56, 59],56}, {[60, 65],60}, {[66, 71],66}, {[72, 79],72}, {[80, 84],80}}."]
    #[doc = ""]
    #[doc = " @param     power  Maximum WiFi transmitting power."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is out of range"]
    pub fn esp_wifi_set_max_tx_power(power: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get maximum transmiting power after WiFi start"]
    #[doc = ""]
    #[doc = " @param     power Maximum WiFi transmitting power, unit is 0.25dBm."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_max_tx_power(power: *mut i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mask to enable or disable some WiFi events"]
    #[doc = ""]
    #[doc = " @attention 1. Mask can be created by logical OR of various WIFI_EVENT_MASK_ constants."]
    #[doc = "               Events which have corresponding bit set in the mask will not be delivered to the system event handler."]
    #[doc = " @attention 2. Default WiFi event mask is WIFI_EVENT_MASK_AP_PROBEREQRECVED."]
    #[doc = " @attention 3. There may be lots of stations sending probe request data around."]
    #[doc = "               Don't unmask this event unless you need to receive probe request data."]
    #[doc = ""]
    #[doc = " @param     mask  WiFi event mask."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_event_mask(mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mask of WiFi events"]
    #[doc = ""]
    #[doc = " @param     mask  WiFi event mask."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_event_mask(mask: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send raw ieee80211 data"]
    #[doc = ""]
    #[doc = " @attention Currently only support for sending beacon/probe request/probe response/action and non-QoS"]
    #[doc = "            data frame"]
    #[doc = ""]
    #[doc = " @param     ifx interface if the Wi-Fi mode is Station, the ifx should be WIFI_IF_STA. If the Wi-Fi"]
    #[doc = "            mode is SoftAP, the ifx should be WIFI_IF_AP. If the Wi-Fi mode is Station+SoftAP, the"]
    #[doc = "            ifx should be WIFI_IF_STA or WIFI_IF_AP. If the ifx is wrong, the API returns ESP_ERR_WIFI_IF."]
    #[doc = " @param     buffer raw ieee80211 buffer"]
    #[doc = " @param     len the length of raw buffer, the len must be <= 1500 Bytes and >= 24 Bytes"]
    #[doc = " @param     en_sys_seq indicate whether use the internal sequence number. If en_sys_seq is false, the"]
    #[doc = "            sequence in raw buffer is unchanged, otherwise it will be overwritten by WiFi driver with"]
    #[doc = "            the system sequence number."]
    #[doc = "            Generally, if esp_wifi_80211_tx is called before the Wi-Fi connection has been set up, both"]
    #[doc = "            en_sys_seq==true and en_sys_seq==false are fine. However, if the API is called after the Wi-Fi"]
    #[doc = "            connection has been set up, en_sys_seq must be true, otherwise ESP_ERR_WIFI_ARG is returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: success"]
    #[doc = "    - ESP_ERR_WIFI_IF: Invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: Invalid parameter"]
    #[doc = "    - ESP_ERR_WIFI_NO_MEM: out of memory"]
    pub fn esp_wifi_80211_tx(
        ifx: wifi_interface_t,
        buffer: *const crate::c_types::c_void,
        len: crate::c_types::c_int,
        en_sys_seq: bool,
    ) -> esp_err_t;
}
#[doc = " @brief The RX callback function of Channel State Information(CSI)  data."]
#[doc = ""]
#[doc = "        Each time a CSI data is received, the callback function will be called."]
#[doc = ""]
#[doc = " @param ctx context argument, passed to esp_wifi_set_csi_rx_cb() when registering callback function."]
#[doc = " @param data CSI data received. The memory that it points to will be deallocated after callback function returns."]
#[doc = ""]
pub type wifi_csi_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void, data: *mut wifi_csi_info_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function of CSI data."]
    #[doc = ""]
    #[doc = "        Each time a CSI data is received, the callback function will be called."]
    #[doc = ""]
    #[doc = " @param cb  callback"]
    #[doc = " @param ctx context argument, passed to callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_csi_rx_cb(cb: wifi_csi_cb_t, ctx: *mut crate::c_types::c_void)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set CSI data configuration"]
    #[doc = ""]
    #[doc = " @param config configuration"]
    #[doc = ""]
    #[doc = " return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi_config(config: *const wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable CSI"]
    #[doc = ""]
    #[doc = " @param en true - enable, false - disable"]
    #[doc = ""]
    #[doc = " return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna GPIO configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna GPIO configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid GPIO number etc"]
    pub fn esp_wifi_set_ant_gpio(config: *const wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna GPIO configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna GPIO configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant_gpio(config: *mut wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid antenna mode or invalid GPIO number"]
    pub fn esp_wifi_set_ant(config: *const wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant(config: *mut wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the TSF time"]
    #[doc = "             In Station mode or SoftAP+Station mode if station is not connected or station doesn't receive at least"]
    #[doc = "             one beacon after connected, will return 0"]
    #[doc = ""]
    #[doc = " @attention  Enabling power save may cause the return value inaccurate, except WiFi modem sleep"]
    #[doc = ""]
    #[doc = " @param      interface The interface whose tsf_time is to be retrieved."]
    #[doc = ""]
    #[doc = " @return     0 or the TSF time"]
    pub fn esp_wifi_get_tsf_time(interface: wifi_interface_t) -> i64;
}
extern "C" {
    #[doc = " @brief     Set the inactive time of the STA or AP"]
    #[doc = ""]
    #[doc = " @attention 1. For Station, If the station does not receive a beacon frame from the connected SoftAP during the inactive time,"]
    #[doc = "               disconnect from SoftAP. Default 6s."]
    #[doc = " @attention 2. For SoftAP, If the softAP doesn't receive any data from the connected STA during inactive time,"]
    #[doc = "               the softAP will force deauth the STA. Default is 300s."]
    #[doc = " @attention 3. The inactive time configuration is not stored into flash"]
    #[doc = ""]
    #[doc = " @param     ifx  interface to be configured."]
    #[doc = " @param     sec  Inactive time. Unit seconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, For Station, if sec is less than 3. For SoftAP, if sec is less than 10."]
    pub fn esp_wifi_set_inactive_time(ifx: wifi_interface_t, sec: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get inactive time of specified interface"]
    #[doc = ""]
    #[doc = " @param     ifx  Interface to be configured."]
    #[doc = " @param     sec  Inactive time. Unit seconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_inactive_time(ifx: wifi_interface_t, sec: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Dump WiFi statistics"]
    #[doc = ""]
    #[doc = " @param     modules statistic modules to be dumped"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_statis_dump(modules: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set RSSI threshold below which APP will get an event"]
    #[doc = ""]
    #[doc = " @attention  This API needs to be called every time after WIFI_EVENT_STA_BSS_RSSI_LOW event is received."]
    #[doc = ""]
    #[doc = " @param      rssi threshold value in dbm between -100 to 0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_set_rssi_threshold(rssi: i32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Start an FTM Initiator session by sending FTM request"]
    #[doc = "             If successful, event WIFI_EVENT_FTM_REPORT is generated with the result of the FTM procedure"]
    #[doc = ""]
    #[doc = " @attention  1. Use this API only in Station mode."]
    #[doc = " @attention  2. If FTM is initiated on a different channel than Station is connected in or internal SoftAP is started in,"]
    #[doc = "                FTM defaults to a single burst in ASAP mode."]
    #[doc = ""]
    #[doc = " @param      cfg  FTM Initiator session configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_ftm_initiate_session(cfg: *mut wifi_ftm_initiator_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      End the ongoing FTM Initiator session"]
    #[doc = ""]
    #[doc = " @attention  This API works only on FTM Initiator"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_ftm_end_session() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set offset in cm for FTM Responder. An equivalent offset is calculated in picoseconds"]
    #[doc = "             and added in TOD of FTM Measurement frame (T1)."]
    #[doc = ""]
    #[doc = " @attention  Use this API only in AP mode before performing FTM as responder"]
    #[doc = ""]
    #[doc = " @param      offset_cm  T1 Offset to be added in centimeters"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_ftm_resp_set_offset(offset_cm: i16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Enable or disable 11b rate of specified interface"]
    #[doc = ""]
    #[doc = " @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start()."]
    #[doc = " @attention  2. Only when really need to disable 11b rate call this API otherwise don't call this."]
    #[doc = ""]
    #[doc = " @param      ifx  Interface to be configured."]
    #[doc = " @param      disable true means disable 11b rate while false means enable 11b rate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_config_11b_rate(ifx: wifi_interface_t, disable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set wake interval for connectionless modules to wake up periodically."]
    #[doc = ""]
    #[doc = " @attention 1. Only one wake interval for all connectionless modules."]
    #[doc = " @attention 2. This configuration could work at connected status."]
    #[doc = "               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status."]
    #[doc = " @attention 3. Event WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START would be posted each time wake interval starts."]
    #[doc = " @attention 4. Recommend to configure interval in multiples of hundred. (e.g. 100ms)"]
    #[doc = " @attention 5. Recommend to configure interval to ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE to get stable performance at coexistence mode."]
    #[doc = ""]
    #[doc = " @param      wake_interval  Milliseconds after would the chip wake up, from 1 to 65535."]
    pub fn esp_wifi_connectionless_module_set_wake_interval(wake_interval: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country"]
    #[doc = ""]
    #[doc = " @attention 1. When ieee80211d_enabled, the country info of the AP to which"]
    #[doc = "               the station is connected is used. E.g. if the configured country is US"]
    #[doc = "               and the country info of the AP to which the station is connected is JP"]
    #[doc = "               then the country info that will be used is JP. If the station disconnected"]
    #[doc = "               from the AP the country info is set back to the country info of the station automatically,"]
    #[doc = "               US in the example."]
    #[doc = " @attention 2. When ieee80211d_enabled is disabled, then the configured country info is used always."]
    #[doc = " @attention 3. When the country info is changed because of configuration or because the station connects to a different"]
    #[doc = "               external AP, the country IE in probe response/beacon of the soft-AP is also changed."]
    #[doc = " @attention 4. The country configuration is stored into flash."]
    #[doc = " @attention 5. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the"]
    #[doc = "               country info."]
    #[doc = " @attention 6. Supported country codes are \"01\"(world safe mode) \"AT\",\"AU\",\"BE\",\"BG\",\"BR\","]
    #[doc = "               \"CA\",\"CH\",\"CN\",\"CY\",\"CZ\",\"DE\",\"DK\",\"EE\",\"ES\",\"FI\",\"FR\",\"GB\",\"GR\",\"HK\",\"HR\",\"HU\","]
    #[doc = "               \"IE\",\"IN\",\"IS\",\"IT\",\"JP\",\"KR\",\"LI\",\"LT\",\"LU\",\"LV\",\"MT\",\"MX\",\"NL\",\"NO\",\"NZ\",\"PL\",\"PT\","]
    #[doc = "               \"RO\",\"SE\",\"SI\",\"SK\",\"TW\",\"US\""]
    #[doc = ""]
    #[doc = " @attention 7. When country code \"01\" (world safe mode) is set, SoftAP mode won't contain country IE."]
    #[doc = " @attention 8. The default country is \"01\" (world safe mode) and ieee80211d_enabled is TRUE."]
    #[doc = " @attention 9. The third octect of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '."]
    #[doc = ""]
    #[doc = " @param     country   the configured country ISO code"]
    #[doc = " @param     ieee80211d_enabled   802.11d is enabled or not"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country_code(
        country: *const crate::c_types::c_char,
        ieee80211d_enabled: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country code"]
    #[doc = ""]
    #[doc = " @param     country  country code"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country_code(country: *mut crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config 80211 tx rate of specified interface"]
    #[doc = ""]
    #[doc = " @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start()."]
    #[doc = ""]
    #[doc = " @param      ifx  Interface to be configured."]
    #[doc = " @param      rate Phy rate to be configured."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_config_80211_tx_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Disable PMF configuration for specified interface"]
    #[doc = ""]
    #[doc = " @attention  This API should be called after esp_wifi_set_config() and before esp_wifi_start()."]
    #[doc = ""]
    #[doc = " @param      ifx  Interface to be configured."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_disable_pmf_config(ifx: wifi_interface_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the Association id assigned to STA by AP"]
    #[doc = ""]
    #[doc = " @param[out] aid  store the aid"]
    #[doc = ""]
    #[doc = " @attention aid = 0 if station is not connected to AP."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_get_aid(aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated phymode after connection."]
    #[doc = ""]
    #[doc = " @param[out] phymode  store the negotiated phymode."]
    #[doc = ""]
    #[doc = " @attention Operation phy mode, BIT[5]: indicate whether LR enabled, BIT[0-4]: wifi_phy_mode_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_get_negotiated_phymode(phymode: *mut wifi_phy_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config dynamic carrier sense"]
    #[doc = ""]
    #[doc = " @attention  This API should be called after esp_wifi_start()."]
    #[doc = ""]
    #[doc = " @param      enabled Dynamic carrier sense is enabled or not."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_set_dynamic_cs(enabled: bool) -> esp_err_t;
}
#[doc = "< protocol: ESPTouch"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH: smartconfig_type_t = 0;
#[doc = "< protocol: AirKiss"]
pub const smartconfig_type_t_SC_TYPE_AIRKISS: smartconfig_type_t = 1;
#[doc = "< protocol: ESPTouch and AirKiss"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_AIRKISS: smartconfig_type_t = 2;
#[doc = "< protocol: ESPTouch v2"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_V2: smartconfig_type_t = 3;
pub type smartconfig_type_t = crate::c_types::c_uint;
#[doc = "< Station smartconfig has finished to scan for APs"]
pub const smartconfig_event_t_SC_EVENT_SCAN_DONE: smartconfig_event_t = 0;
#[doc = "< Station smartconfig has found the channel of the target AP"]
pub const smartconfig_event_t_SC_EVENT_FOUND_CHANNEL: smartconfig_event_t = 1;
#[doc = "< Station smartconfig got the SSID and password"]
pub const smartconfig_event_t_SC_EVENT_GOT_SSID_PSWD: smartconfig_event_t = 2;
#[doc = "< Station smartconfig has sent ACK to cellphone"]
pub const smartconfig_event_t_SC_EVENT_SEND_ACK_DONE: smartconfig_event_t = 3;
#[doc = " Smartconfig event declarations"]
pub type smartconfig_event_t = crate::c_types::c_uint;
extern "C" {
    pub static SC_EVENT: esp_event_base_t;
}
#[doc = " Argument structure for SC_EVENT_GOT_SSID_PSWD event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smartconfig_event_got_ssid_pswd_t {
    #[doc = "< SSID of the AP. Null terminated string."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of the AP. Null terminated string."]
    pub password: [u8; 64usize],
    #[doc = "< whether set MAC address of target AP or not."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP."]
    pub bssid: [u8; 6usize],
    #[doc = "< Type of smartconfig(ESPTouch or AirKiss)."]
    pub type_: smartconfig_type_t,
    #[doc = "< Token from cellphone which is used to send ACK to cellphone."]
    pub token: u8,
    #[doc = "< IP address of cellphone."]
    pub cellphone_ip: [u8; 4usize],
}
#[doc = " Configure structure for esp_smartconfig_start"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smartconfig_start_config_t {
    #[doc = "< Enable smartconfig logs."]
    pub enable_log: bool,
    #[doc = "< Enable ESPTouch v2 crypt."]
    pub esp_touch_v2_enable_crypt: bool,
    #[doc = "< ESPTouch v2 crypt key, len should be 16."]
    pub esp_touch_v2_key: *mut crate::c_types::c_char,
}
extern "C" {
    #[doc = " @brief  Get the version of SmartConfig."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - SmartConfig version const char."]
    pub fn esp_smartconfig_get_version() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP."]
    #[doc = "            Device sniffer special packets from the air that containing SSID and password of target AP."]
    #[doc = ""]
    #[doc = " @attention 1. This API can be called in station or softAP-station mode."]
    #[doc = " @attention 2. Can not call esp_smartconfig_start twice before it finish, please call"]
    #[doc = "               esp_smartconfig_stop first."]
    #[doc = ""]
    #[doc = " @param     config pointer to smartconfig start configure structure"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start."]
    #[doc = ""]
    #[doc = " @attention Whether connect to AP succeed or not, this API should be called to free"]
    #[doc = "            memory taken by smartconfig_start."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set timeout of SmartConfig process."]
    #[doc = ""]
    #[doc = " @attention Timing starts from SC_STATUS_FIND_CHANNEL status. SmartConfig will restart if timeout."]
    #[doc = ""]
    #[doc = " @param     time_s  range 15s~255s, offset:45s."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_esptouch_set_timeout(time_s: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of SmartConfig."]
    #[doc = ""]
    #[doc = " @attention If users need to set the SmartConfig type, please set it before calling"]
    #[doc = "            esp_smartconfig_start."]
    #[doc = ""]
    #[doc = " @param     type  Choose from the smartconfig_type_t."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_set_type(type_: smartconfig_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mode of SmartConfig. default normal mode."]
    #[doc = ""]
    #[doc = " @attention 1. Please call it before API esp_smartconfig_start."]
    #[doc = " @attention 2. Fast mode have corresponding APP(phone)."]
    #[doc = " @attention 3. Two mode is compatible."]
    #[doc = ""]
    #[doc = " @param     enable  false-disable(default); true-enable;"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_fast_mode(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get reserved data of ESPTouch v2."]
    #[doc = ""]
    #[doc = " @param     rvd_data  reserved  data"]
    #[doc = " @param     len length  of  reserved data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_get_rvd_data(rvd_data: *mut u8, len: u8) -> esp_err_t;
}
#[doc = "< Set the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_SET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 1;
#[doc = "< Get the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_GET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 2;
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_MAX: wifi_ioctl_cmd_t = 3;
#[doc = " @brief WiFi ioctl command type"]
#[doc = ""]
pub type wifi_ioctl_cmd_t = crate::c_types::c_uint;
#[doc = " @brief Configuration for STA's HT2040 coexist management"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ht2040_coex_t {
    #[doc = "< Indicate whether STA's HT2040 coexist management is enabled or not"]
    pub enable: crate::c_types::c_int,
}
#[doc = " @brief Configuration for WiFi ioctl"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ioctl_config_t {
    #[doc = "< Configuration of ioctl command"]
    pub data: wifi_ioctl_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_ioctl_config_t__bindgen_ty_1 {
    #[doc = "< Configuration of STA's HT2040 coexist management"]
    pub ht2040_coex: wifi_ht2040_coex_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_static_queue_t {
    #[doc = "< FreeRTOS queue handler"]
    pub handle: QueueHandle_t,
    #[doc = "< storage for FreeRTOS queue"]
    pub storage: *mut crate::c_types::c_void,
}
pub const wifi_log_level_t_WIFI_LOG_NONE: wifi_log_level_t = 0;
pub const wifi_log_level_t_WIFI_LOG_ERROR: wifi_log_level_t = 1;
pub const wifi_log_level_t_WIFI_LOG_WARNING: wifi_log_level_t = 2;
pub const wifi_log_level_t_WIFI_LOG_INFO: wifi_log_level_t = 3;
pub const wifi_log_level_t_WIFI_LOG_DEBUG: wifi_log_level_t = 4;
pub const wifi_log_level_t_WIFI_LOG_VERBOSE: wifi_log_level_t = 5;
#[doc = " @brief WiFi log level"]
#[doc = ""]
pub type wifi_log_level_t = crate::c_types::c_uint;
pub const wifi_log_module_t_WIFI_LOG_MODULE_ALL: wifi_log_module_t = 0;
pub const wifi_log_module_t_WIFI_LOG_MODULE_WIFI: wifi_log_module_t = 1;
pub const wifi_log_module_t_WIFI_LOG_MODULE_COEX: wifi_log_module_t = 2;
pub const wifi_log_module_t_WIFI_LOG_MODULE_MESH: wifi_log_module_t = 3;
#[doc = " @brief WiFi log module definition"]
#[doc = ""]
pub type wifi_log_module_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Initialize Wi-Fi Driver"]
    #[doc = "     Alloc resource for WiFi driver, such as WiFi control structure, RX/TX buffer,"]
    #[doc = "     WiFi NVS structure among others."]
    #[doc = ""]
    #[doc = " For the most part, you need not call this function directly. It gets called"]
    #[doc = " from esp_wifi_init()."]
    #[doc = ""]
    #[doc = " This function may be called, if you only need to initialize the Wi-Fi driver"]
    #[doc = " without having to use the network stack on top."]
    #[doc = ""]
    #[doc = " @param  config provide WiFi init configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init_internal(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize Wi-Fi Driver"]
    #[doc = "     Free resource for WiFi driver, such as WiFi control structure, RX/TX buffer,"]
    #[doc = "     WiFi NVS structure among others."]
    #[doc = ""]
    #[doc = " For the most part, you need not call this function directly. It gets called"]
    #[doc = " from esp_wifi_deinit()."]
    #[doc = ""]
    #[doc = " This function may be called, if you call esp_wifi_init_internal to initialize"]
    #[doc = " WiFi driver."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_deinit_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  free the rx buffer which allocated by wifi driver"]
    #[doc = ""]
    #[doc = " @param  void* buffer: rx buffer pointer"]
    pub fn esp_wifi_internal_free_rx_buffer(buffer: *mut crate::c_types::c_void);
}
extern "C" {
    #[doc = " @brief  transmit the buffer via wifi driver"]
    #[doc = ""]
    #[doc = " This API makes a copy of the input buffer and then forwards the buffer"]
    #[doc = " copy to WiFi driver."]
    #[doc = ""]
    #[doc = " @param  wifi_interface_t wifi_if : wifi interface id"]
    #[doc = " @param  void *buffer : the buffer to be transmit"]
    #[doc = " @param  uint16_t len : the length of buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK  : Successfully transmit the buffer to wifi driver"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF : WiFi interface is invalid"]
    #[doc = "    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started"]
    #[doc = "    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started"]
    #[doc = "    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated"]
    #[doc = "    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication"]
    #[doc = "    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx(
        wifi_if: wifi_interface_t,
        buffer: *mut crate::c_types::c_void,
        len: u16,
    ) -> crate::c_types::c_int;
}
#[doc = " @brief     The net stack buffer reference counter callback function"]
#[doc = ""]
pub type wifi_netstack_buf_ref_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut crate::c_types::c_void)>;
#[doc = " @brief     The net stack buffer free callback function"]
#[doc = ""]
pub type wifi_netstack_buf_free_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut crate::c_types::c_void)>;
extern "C" {
    #[doc = " @brief  transmit the buffer by reference via wifi driver"]
    #[doc = ""]
    #[doc = " This API firstly increases the reference counter of the input buffer and"]
    #[doc = " then forwards the buffer to WiFi driver. The WiFi driver will free the buffer"]
    #[doc = " after processing it. Use esp_wifi_internal_tx() if the uplayer buffer doesn't"]
    #[doc = " supports reference counter."]
    #[doc = ""]
    #[doc = " @param  wifi_if : wifi interface id"]
    #[doc = " @param  buffer : the buffer to be tansmit"]
    #[doc = " @param  len : the length of buffer"]
    #[doc = " @param  netstack_buf : the netstack buffer related to bufffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK  : Successfully transmit the buffer to wifi driver"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF : WiFi interface is invalid"]
    #[doc = "    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started"]
    #[doc = "    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started"]
    #[doc = "    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated"]
    #[doc = "    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication"]
    #[doc = "    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx_by_ref(
        ifx: wifi_interface_t,
        buffer: *mut crate::c_types::c_void,
        len: size_t,
        netstack_buf: *mut crate::c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Initialize WAPI function when wpa_supplicant initialize."]
    #[doc = ""]
    #[doc = " This API is privately used, be careful not open to external applicantion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_WAPI_INTERNAL : Internal error"]
    pub fn esp_wifi_internal_wapi_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize WAPI function when wpa_supplicant de-initialize."]
    #[doc = ""]
    #[doc = " This API is privately used, be careful not open to external applicantion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    pub fn esp_wifi_internal_wapi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  register the net stack buffer reference increasing and free callback"]
    #[doc = ""]
    #[doc = " @param  ref : net stack buffer reference callback"]
    #[doc = " @param  free: net stack buffer free callback"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK  : Successfully transmit the buffer to wifi driver"]
    #[doc = "    - others  : failed to register the callback"]
    pub fn esp_wifi_internal_reg_netstack_buf_cb(
        ref_: wifi_netstack_buf_ref_cb_t,
        free: wifi_netstack_buf_free_cb_t,
    ) -> esp_err_t;
}
#[doc = " @brief     The WiFi RX callback function"]
#[doc = ""]
#[doc = "            Each time the WiFi need to forward the packets to high layer, the callback function will be called"]
pub type wifi_rxcb_t = ::core::option::Option<
    unsafe extern "C" fn(
        buffer: *mut crate::c_types::c_void,
        len: u16,
        eb: *mut crate::c_types::c_void,
    ) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief     Set the WiFi RX callback"]
    #[doc = ""]
    #[doc = " @attention 1. Currently we support only one RX callback for each interface"]
    #[doc = ""]
    #[doc = " @param     wifi_interface_t ifx : interface"]
    #[doc = " @param     wifi_rxcb_t fn : WiFi RX callback"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - others : fail"]
    pub fn esp_wifi_internal_reg_rxcb(ifx: wifi_interface_t, fn_: wifi_rxcb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Notify WIFI driver that the station got ip successfully"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - others : fail"]
    pub fn esp_wifi_internal_set_sta_ip() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  enable or disable transmitting WiFi MAC frame with fixed rate"]
    #[doc = ""]
    #[doc = " @attention 1. If fixed rate is enabled, both management and data frame are transmitted with fixed rate"]
    #[doc = " @attention 2. Make sure that the receiver is able to receive the frame with the fixed rate if you want the frame to be received"]
    #[doc = " @attention 3. Not support to set fix rate for espnow and 80211_tx"]
    #[doc = ""]
    #[doc = " @param  ifx : wifi interface"]
    #[doc = " @param  en : false - disable, true - enable"]
    #[doc = " @param  rate : PHY rate"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ERR_OK  : succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_IF : invalid WiFi interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG : invalid rate"]
    #[doc = "    - ESP_ERR_NOT_SUPPORTED : do not support to set fixed rate if TX AMPDU is enabled"]
    pub fn esp_wifi_internal_set_fix_rate(
        ifx: wifi_interface_t,
        en: bool,
        rate: wifi_phy_rate_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP."]
    #[doc = "            Device sniffer special packets from the air that containing SSID and password of target AP."]
    #[doc = ""]
    #[doc = " @attention 1. This API can be called in station or softAP-station mode."]
    #[doc = " @attention 2. Can not call esp_smartconfig_start twice before it finish, please call"]
    #[doc = "               esp_smartconfig_stop first."]
    #[doc = ""]
    #[doc = " @param     config pointer to smartconfig start configure structure"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_internal_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start."]
    #[doc = ""]
    #[doc = " @attention Whether connect to AP succeed or not, this API should be called to free"]
    #[doc = "            memory taken by smartconfig_start."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_internal_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the OS adapter header files in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_osi_funcs_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the crypto types header files in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_crypto_funcs_md5_check(
        md5: *const crate::c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_types.h in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_wifi_type_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_he_types.h in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_wifi_he_type_md5_check(
        md5: *const crate::c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi.h in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_esp_wifi_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_he.h in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_esp_wifi_he_md5_check(md5: *const crate::c_types::c_char)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Allocate a chunk of memory for WiFi driver"]
    #[doc = ""]
    #[doc = " @attention This API is not used for DMA memory allocation."]
    #[doc = ""]
    #[doc = " @param     size_t size : Size, in bytes, of the amount of memory to allocate"]
    #[doc = ""]
    #[doc = " @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_malloc(size: size_t) -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief     Reallocate a chunk of memory for WiFi driver"]
    #[doc = ""]
    #[doc = " @attention This API is not used for DMA memory allocation."]
    #[doc = ""]
    #[doc = " @param     void * ptr  : Pointer to previously allocated memory, or NULL for a new allocation."]
    #[doc = " @param     size_t size : Size, in bytes, of the amount of memory to allocate"]
    #[doc = ""]
    #[doc = " @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_realloc(
        ptr: *mut crate::c_types::c_void,
        size: size_t,
    ) -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief     Callocate memory for WiFi driver"]
    #[doc = ""]
    #[doc = " @attention This API is not used for DMA memory allocation."]
    #[doc = ""]
    #[doc = " @param     size_t n    : Number of continuing chunks of memory to allocate"]
    #[doc = " @param     size_t size : Size, in bytes, of the amount of memory to allocate"]
    #[doc = ""]
    #[doc = " @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_calloc(n: size_t, size: size_t) -> *mut crate::c_types::c_void;
}
#[doc = " @brief     Update WiFi MAC time"]
#[doc = ""]
#[doc = " @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled"]
#[doc = ""]
#[doc = " @return    Always returns ESP_OK"]
pub type wifi_mac_time_update_cb_t =
    ::core::option::Option<unsafe extern "C" fn(time_delta: u32) -> esp_err_t>;
extern "C" {
    #[doc = " @brief     Update WiFi MAC time"]
    #[doc = ""]
    #[doc = " @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled"]
    #[doc = ""]
    #[doc = " @return    Always returns ESP_OK"]
    pub fn esp_wifi_internal_update_mac_time(time_delta: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi log level"]
    #[doc = ""]
    #[doc = " @param     level   Log level."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_FAIL: level is invalid"]
    pub fn esp_wifi_internal_set_log_level(level: wifi_log_level_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current log module and submodule"]
    #[doc = ""]
    #[doc = " @param     module      Log module"]
    #[doc = " @param     submodule   Log submodule"]
    #[doc = " @param     enable      enable or disable"]
    #[doc = "            If module == 0 && enable == 0, all log modules are disabled."]
    #[doc = "            If module == 0 && enable == 1, all log modules are enabled."]
    #[doc = "            If submodule == 0 && enable == 0, all log submodules are disabled."]
    #[doc = "            If submodule == 0 && enable == 1, all log submodules are enabled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_internal_set_log_mod(
        module: wifi_log_module_t,
        submodule: u32,
        enable: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi log info"]
    #[doc = ""]
    #[doc = " @param     log_level  the return log level."]
    #[doc = " @param     log_mod    the return log module and submodule"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_log(
        log_level: *mut wifi_log_level_t,
        log_mod: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     A general API to set/get WiFi internal configuration, it's for debug only"]
    #[doc = ""]
    #[doc = " @param     cmd : ioctl command type"]
    #[doc = " @param     cfg : configuration for the command"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_internal_ioctl(
        cmd: crate::c_types::c_int,
        cfg: *mut wifi_ioctl_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the user-configured channel info"]
    #[doc = ""]
    #[doc = " @param     ifx : WiFi interface"]
    #[doc = " @param     primary : store the configured primary channel"]
    #[doc = " @param     second : store the configured second channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_config_channel(
        ifx: wifi_interface_t,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated channel info after WiFi connection established"]
    #[doc = ""]
    #[doc = " @param     ifx : WiFi interface"]
    #[doc = " @param     aid : the connection number when a STA connects to the softAP"]
    #[doc = " @param     primary : store the negotiated primary channel"]
    #[doc = " @param     second : store the negotiated second channel"]
    #[doc = " @attention the aid param is only works when the device in softAP/softAP+STA mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_channel(
        ifx: wifi_interface_t,
        aid: u8,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated bandwidth info after WiFi connection established"]
    #[doc = ""]
    #[doc = " @param     ifx : WiFi interface"]
    #[doc = " @param     bw : store the negotiated bandwidth"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_bandwidth(
        ifx: wifi_interface_t,
        aid: u8,
        bw: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wifi power domain power on"]
    pub fn esp_wifi_power_domain_on();
}
extern "C" {
    #[doc = " @brief Wifi power domain power off"]
    pub fn esp_wifi_power_domain_off();
}
#[doc = " @breif    TxDone callback function type. Should be registered using esp_wifi_set_tx_done_cb()"]
#[doc = ""]
#[doc = " @param    ifidx The interface id that the tx callback has been triggered from"]
#[doc = " @param    data Pointer to the data transmitted"]
#[doc = " @param    data_len Length of the data transmitted"]
#[doc = " @param    txStatus True:if the data was transmitted sucessfully False: if data transmission failed"]
pub type wifi_tx_done_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ifidx: u8, data: *mut u8, data_len: *mut u16, txStatus: bool),
>;
extern "C" {
    #[doc = " @brief    Register the txDone callback function of type wifi_tx_done_cb_t"]
    #[doc = ""]
    #[doc = " @param    cb The callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_set_tx_done_cb(cb: wifi_tx_done_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set device spp amsdu attributes"]
    #[doc = ""]
    #[doc = " @param     ifx: WiFi interface"]
    #[doc = " @param     spp_cap: spp amsdu capable"]
    #[doc = " @param     spp_req: spp amsdu require"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "     - ESP_ERR_WIFI_IF : invalid WiFi interface"]
    pub fn esp_wifi_internal_set_spp_amsdu(
        ifidx: wifi_interface_t,
        spp_cap: bool,
        spp_req: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Update WIFI light sleep default parameters"]
    #[doc = ""]
    #[doc = " @param   min_freq_mhz: minimum frequency of DFS"]
    #[doc = " @param   max_freq_mhz: maximum frequency of DFS"]
    pub fn esp_wifi_internal_update_light_sleep_default_params(
        min_freq_mhz: crate::c_types::c_int,
        max_freq_mhz: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " @brief   Set the delay time for wifi to enter the sleep state when light sleep"]
    #[doc = ""]
    #[doc = " @param   return_to_sleep_delay: minimum timeout time  for waiting to receive"]
    #[doc = "                      data, when no data is received during the timeout period,"]
    #[doc = "                      the wifi enters the sleep process."]
    pub fn esp_wifi_set_sleep_delay_time(return_to_sleep_delay: u32);
}
extern "C" {
    #[doc = " @brief   Set wifi keep alive time"]
    #[doc = ""]
    #[doc = " @param   keep_alive_time: keep alive time"]
    pub fn esp_wifi_set_keep_alive_time(keep_alive_time: u32);
}
extern "C" {
    #[doc = " @brief   Configure wifi beacon montior default parameters"]
    #[doc = ""]
    #[doc = " @param   config: the configuration parameters for wifi beacon monitor"]
    pub fn esp_wifi_beacon_monitor_configure(config: *mut wifi_beacon_monitor_config_t);
}
extern "C" {
    #[doc = " @brief   Require WiFi to enable or disable Advanced DTIM sleep function"]
    #[doc = ""]
    #[doc = " @param   light_sleep_enable: true for light sleep mode is enabled, false for light sleep mode is disabled."]
    #[doc = " @param   modem_state_enable: true for require WiFi to enable Advanced DTIM sleep function,"]
    #[doc = "                              false for require WiFi to disable Advanced DTIM sleep function."]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_mac_sleep_configure(
        light_sleep_enable: bool,
        modem_state_enable: bool,
    );
}
extern "C" {
    #[doc = " @brief      Start Publishing a service in the NAN cluster"]
    #[doc = ""]
    #[doc = " @attention  This API should be called after esp_wifi_start() in NAN Mode."]
    #[doc = ""]
    #[doc = " @param      publish_cfg  Configuration parameters for publishing a service."]
    #[doc = " @param      id  Identifier for the Publish service."]
    #[doc = " @param      cancel  Cancel the service identified by the id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_nan_internal_publish_service(
        publish_cfg: *const wifi_nan_publish_cfg_t,
        id: *mut u8,
        cancel: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Subscribe for a service within the NAN cluster"]
    #[doc = ""]
    #[doc = " @attention  This API should be called after esp_wifi_start() in NAN Mode."]
    #[doc = ""]
    #[doc = " @param      subscribe_cfg  Configuration parameters for subscribing for a service."]
    #[doc = " @param      id  Identifier for the Subscribe service."]
    #[doc = " @param      cancel  Cancel the service identified by the id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_nan_internal_subscribe_service(
        subscribe_cfg: *const wifi_nan_subscribe_cfg_t,
        id: *mut u8,
        cancel: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Follow-up to the Publisher with matching service"]
    #[doc = ""]
    #[doc = " @attention  This API should be called after WIFI_EVENT_NAN_SVC_MATCH event is received."]
    #[doc = ""]
    #[doc = " @param      fup_params  Configuration parameters for sending a Follow-up to the Peer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_nan_internal_send_followup(
        fup_params: *const wifi_nan_followup_params_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Datapath Request to the Publisher with matching service"]
    #[doc = ""]
    #[doc = " @attention  This API should be called after WIFI_EVENT_NAN_SVC_MATCH event is received."]
    #[doc = ""]
    #[doc = " @param      req  NAN Datapath Request parameters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_nan_internal_datapath_req(
        req: *mut wifi_nan_datapath_req_t,
        ndp_id: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send Datapath Response to accept or reject the received request"]
    #[doc = ""]
    #[doc = " @attention  This API should be called on the Publisher after receiving WIFI_EVENT_NDP_INDICATION event."]
    #[doc = ""]
    #[doc = " @param      resp  NAN Datapath Response parameters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_nan_internal_datapath_resp(resp: *mut wifi_nan_datapath_resp_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      End NAN Datapath that is active"]
    #[doc = ""]
    #[doc = " @attention  This API should be called after receiving WIFI_EVENT_NDP_CONFIRM event."]
    #[doc = ""]
    #[doc = " @param      req  NAN Datapath end request parameters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_nan_internal_datapath_end(req: *mut wifi_nan_datapath_end_req_t) -> esp_err_t;
}
extern "C" {
    pub static g_wifi_default_mesh_crypto_funcs: mesh_crypto_funcs_t;
}
extern "C" {
    #[doc = " @brief     Supplicant initialization"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_NO_MEM : out of memory"]
    pub fn esp_supplicant_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Supplicant deinitialization"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - others: failed"]
    pub fn esp_supplicant_deinit() -> esp_err_t;
}
#[doc = " @brief Structure holding PHY init parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_init_data_t {
    #[doc = "< opaque PHY initialization parameters"]
    pub params: [u8; 128usize],
}
#[doc = " @brief Opaque PHY calibration data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_calibration_data_t {
    #[doc = "< PHY version"]
    pub version: [u8; 4usize],
    #[doc = "< The MAC address of the station"]
    pub mac: [u8; 6usize],
    #[doc = "< calibration data"]
    pub opaque: [u8; 1894usize],
}
#[doc = "< Do part of RF calibration. This should be used after power-on reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_PARTIAL: esp_phy_calibration_mode_t = 0;
#[doc = "< Don't do any RF calibration. This mode is only suggested to be used after deep sleep reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_NONE: esp_phy_calibration_mode_t = 1;
#[doc = "< Do full RF calibration. Produces best results, but also consumes a lot of time and current. Suggested to be used once."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_FULL: esp_phy_calibration_mode_t = 2;
#[doc = " @brief PHY calibration mode"]
#[doc = ""]
pub type esp_phy_calibration_mode_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Get PHY init data"]
    #[doc = ""]
    #[doc = " If \"Use a partition to store PHY init data\" option is set in menuconfig,"]
    #[doc = " This function will load PHY init data from a partition. Otherwise,"]
    #[doc = " PHY init data will be compiled into the application itself, and this function"]
    #[doc = " will return a pointer to PHY init data located in read-only memory (DROM)."]
    #[doc = ""]
    #[doc = " If \"Use a partition to store PHY init data\" option is enabled, this function"]
    #[doc = " may return NULL if the data loaded from flash is not valid."]
    #[doc = ""]
    #[doc = " @note Call esp_phy_release_init_data to release the pointer obtained using"]
    #[doc = " this function after the call to esp_wifi_init."]
    #[doc = ""]
    #[doc = " @return pointer to PHY init data structure"]
    pub fn esp_phy_get_init_data() -> *const esp_phy_init_data_t;
}
extern "C" {
    #[doc = " @brief Release PHY init data"]
    #[doc = " @param data  pointer to PHY init data structure obtained from"]
    #[doc = "              esp_phy_get_init_data function"]
    pub fn esp_phy_release_init_data(data: *const esp_phy_init_data_t);
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_init to load PHY calibration data"]
    #[doc = ""]
    #[doc = " This is a convenience function which can be used to load PHY calibration"]
    #[doc = " data from NVS. Data can be stored to NVS using esp_phy_store_cal_data_to_nvs"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " If calibration data is not present in the NVS, or"]
    #[doc = " data is not valid (was obtained for a chip with a different MAC address,"]
    #[doc = " or obtained for a different version of software), this function will"]
    #[doc = " return an error."]
    #[doc = ""]
    #[doc = " If \"Initialize PHY in startup code\" option is set in menuconfig, this"]
    #[doc = " function will be used to load calibration data. To provide a different"]
    #[doc = " mechanism for loading calibration data, disable"]
    #[doc = " \"Initialize PHY in startup code\" option in menuconfig and call esp_phy_init"]
    #[doc = " function from the application. For an example usage of esp_phy_init and"]
    #[doc = " this function, see esp_phy_store_cal_data_to_nvs function in cpu_start.c"]
    #[doc = ""]
    #[doc = " @param out_cal_data pointer to calibration data structure to be filled with"]
    #[doc = "                     loaded data."]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_phy_load_cal_data_from_nvs(
        out_cal_data: *mut esp_phy_calibration_data_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_init to store PHY calibration data"]
    #[doc = ""]
    #[doc = " This is a convenience function which can be used to store PHY calibration"]
    #[doc = " data to the NVS. Calibration data is returned by esp_phy_init function."]
    #[doc = " Data saved using this function to the NVS can later be loaded using"]
    #[doc = " esp_phy_store_cal_data_to_nvs function."]
    #[doc = ""]
    #[doc = " If \"Initialize PHY in startup code\" option is set in menuconfig, this"]
    #[doc = " function will be used to store calibration data. To provide a different"]
    #[doc = " mechanism for storing calibration data, disable"]
    #[doc = " \"Initialize PHY in startup code\" option in menuconfig and call esp_phy_init"]
    #[doc = " function from the application."]
    #[doc = ""]
    #[doc = " @param cal_data pointer to calibration data which has to be saved."]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_phy_store_cal_data_to_nvs(cal_data: *const esp_phy_calibration_data_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase PHY calibration data which is stored in the NVS"]
    #[doc = ""]
    #[doc = " This is a function which can be used to trigger full calibration as a last-resort remedy"]
    #[doc = " if partial calibration is used. It can be called in the application based on some conditions"]
    #[doc = " (e.g. an option provided in some diagnostic mode)."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    #[doc = " @return others on fail. Please refer to NVS API return value error number."]
    pub fn esp_phy_erase_cal_data_in_nvs() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable PHY and RF module"]
    #[doc = ""]
    #[doc = " PHY and RF module should be enabled in order to use WiFi or BT."]
    #[doc = " Now PHY and RF enabling job is done automatically when start WiFi or BT. Users should not"]
    #[doc = " call this API in their application."]
    #[doc = ""]
    pub fn esp_phy_enable();
}
extern "C" {
    #[doc = " @brief Disable PHY and RF module"]
    #[doc = ""]
    #[doc = " PHY module should be disabled in order to shutdown WiFi or BT."]
    #[doc = " Now PHY and RF disabling job is done automatically when stop WiFi or BT. Users should not"]
    #[doc = " call this API in their application."]
    #[doc = ""]
    pub fn esp_phy_disable();
}
extern "C" {
    #[doc = " @brief Enable BTBB module"]
    #[doc = ""]
    #[doc = " BTBB module should be enabled in order to use IEEE802154 or BT."]
    #[doc = " Now BTBB enabling job is done automatically when start IEEE802154 or BT. Users should not"]
    #[doc = " call this API in their application."]
    #[doc = ""]
    pub fn esp_btbb_enable();
}
extern "C" {
    #[doc = " @brief Disable BTBB module"]
    #[doc = ""]
    #[doc = " Dsiable BTBB module, used by IEEE802154 or Bluetooth."]
    #[doc = " Users should not call this API in their application."]
    #[doc = ""]
    pub fn esp_btbb_disable();
}
extern "C" {
    #[doc = " @brief Load calibration data from NVS and initialize PHY and RF module"]
    pub fn esp_phy_load_cal_and_init();
}
extern "C" {
    #[doc = " @brief Initialize backup memory for Phy power up/down"]
    pub fn esp_phy_modem_init();
}
extern "C" {
    #[doc = " @brief Deinitialize backup memory for Phy power up/down"]
    #[doc = " Set phy_init_flag if all modems deinit on ESP32C3"]
    pub fn esp_phy_modem_deinit();
}
extern "C" {
    #[doc = " @brief Enable WiFi/BT common clock"]
    #[doc = ""]
    pub fn esp_phy_common_clock_enable();
}
extern "C" {
    #[doc = " @brief Disable WiFi/BT common clock"]
    #[doc = ""]
    pub fn esp_phy_common_clock_disable();
}
extern "C" {
    #[doc = " @brief            Get the time stamp when PHY/RF was switched on"]
    #[doc = " @return           return 0 if PHY/RF is never switched on. Otherwise return time in"]
    #[doc = "                   microsecond since boot when phy/rf was last switched on"]
    pub fn esp_phy_rf_get_on_ts() -> i64;
}
extern "C" {
    #[doc = " @brief Update the corresponding PHY init type according to the country code of Wi-Fi."]
    #[doc = ""]
    #[doc = " @param country country code"]
    #[doc = " @return ESP_OK on success."]
    #[doc = " @return esp_err_t code describing the error on fail"]
    pub fn esp_phy_update_country_info(country: *const crate::c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get PHY lib version"]
    #[doc = " @return PHY lib version."]
    pub fn get_phy_version_str() -> *mut crate::c_types::c_char;
}
pub const phy_i2c_master_command_type_t_PHY_I2C_MST_CMD_TYPE_OFF: phy_i2c_master_command_type_t = 0;
pub const phy_i2c_master_command_type_t_PHY_I2C_MST_CMD_TYPE_ON: phy_i2c_master_command_type_t = 1;
pub const phy_i2c_master_command_type_t_PHY_I2C_MST_CMD_TYPE_MAX: phy_i2c_master_command_type_t = 2;
pub type phy_i2c_master_command_type_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t {
    pub config: [phy_i2c_master_command_attribute_t__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t__bindgen_ty_1 {
    pub start: u8,
    pub end: u8,
    pub host_id: u8,
}
extern "C" {
    #[doc = " @brief Return ROM function pointer table from PHY library."]
    pub fn phy_get_romfunc_addr();
}
extern "C" {
    #[doc = " @brief Initialize PHY module and do RF calibration"]
    #[doc = " @param[in] init_data Initialization parameters to be used by the PHY"]
    #[doc = " @param[inout] cal_data As input, calibration data previously obtained. As output, will contain new calibration data."]
    #[doc = " @param[in] cal_mode  RF calibration mode"]
    #[doc = " @return ESP_CAL_DATA_CHECK_FAIL if calibration data checksum fails, other values are reserved for future use"]
    pub fn register_chipv7_phy(
        init_data: *const esp_phy_init_data_t,
        cal_data: *mut esp_phy_calibration_data_t,
        cal_mode: esp_phy_calibration_mode_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get the format version of calibration data used by PHY library."]
    #[doc = " @return Format version number, OR'ed with BIT(16) if PHY is in WIFI only mode."]
    pub fn phy_get_rf_cal_version() -> u32;
}
extern "C" {
    #[doc = " @brief Set RF/BB for only WIFI mode or coexist(WIFI & BT) mode"]
    #[doc = " @param[in] true is for only WIFI mode, false is for coexist mode. default is 0."]
    #[doc = " @return NULL"]
    pub fn phy_set_wifi_mode_only(wifi_only: bool);
}
extern "C" {
    #[doc = " @brief Set BT the highest priority in coexist mode."]
    #[doc = " @return NULL"]
    pub fn coex_bt_high_prio();
}
extern "C" {
    #[doc = " @brief Open PHY and RF."]
    pub fn phy_wakeup_init();
}
extern "C" {
    #[doc = " @brief Shutdown PHY and RF."]
    pub fn phy_close_rf();
}
extern "C" {
    #[doc = " @brief Disable PHY temperature sensor."]
    pub fn phy_xpd_tsens();
}
extern "C" {
    #[doc = " @brief Update internal state of PHY when wifi deinit powers off the wifi power domain."]
    pub fn phy_init_flag();
}
extern "C" {
    #[doc = " @brief Store and load PHY digital registers."]
    #[doc = ""]
    #[doc = " @param     backup_en  if backup_en is true, store PHY digital registers to memory. Otherwise load PHY digital registers from memory"]
    #[doc = " @param     mem_addr   Memory address to store and load PHY digital registers"]
    #[doc = ""]
    #[doc = " @return    memory size"]
    pub fn phy_dig_reg_backup(backup_en: bool, mem_addr: *mut u32) -> u8;
}
extern "C" {
    #[doc = " @brief Enable or disable USB when phy init."]
    pub fn phy_bbpll_en_usb(en: bool);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_channel_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM channel handle"]
pub type esp_etm_channel_handle_t = *mut esp_etm_channel_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_event_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM event handle"]
pub type esp_etm_event_handle_t = *mut esp_etm_event_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_task_t {
    _unused: [u8; 0],
}
#[doc = " @brief ETM task handle"]
pub type esp_etm_task_handle_t = *mut esp_etm_task_t;
#[doc = " @brief ETM channel configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_etm_channel_config_t {}
extern "C" {
    #[doc = " @brief Allocate an ETM channel"]
    #[doc = ""]
    #[doc = " @note The channel can later be freed by `esp_etm_del_channel`"]
    #[doc = ""]
    #[doc = " @param[in] config ETM channel configuration"]
    #[doc = " @param[out] ret_chan Returned ETM channel handle"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Allocate ETM channel successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Allocate ETM channel failed because of invalid argument"]
    #[doc = "      - ESP_ERR_NO_MEM: Allocate ETM channel failed because of out of memory"]
    #[doc = "      - ESP_ERR_NOT_FOUND: Allocate ETM channel failed because all channels are used up and no more free one"]
    #[doc = "      - ESP_FAIL: Allocate ETM channel failed because of other reasons"]
    pub fn esp_etm_new_channel(
        config: *const esp_etm_channel_config_t,
        ret_chan: *mut esp_etm_channel_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an ETM channel"]
    #[doc = ""]
    #[doc = " @param[in] chan ETM channel handle that created by `esp_etm_new_channel`"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Delete ETM channel successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Delete ETM channel failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: Delete ETM channel failed because of other reasons"]
    pub fn esp_etm_del_channel(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable ETM channel"]
    #[doc = ""]
    #[doc = " @note This function will transit the channel state from init to enable."]
    #[doc = ""]
    #[doc = " @param[in] chan ETM channel handle that created by `esp_etm_new_channel`"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Enable ETM channel successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Enable ETM channel failed because of invalid argument"]
    #[doc = "      - ESP_ERR_INVALID_STATE: Enable ETM channel failed because the channel has been enabled already"]
    #[doc = "      - ESP_FAIL: Enable ETM channel failed because of other reasons"]
    pub fn esp_etm_channel_enable(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable ETM channel"]
    #[doc = ""]
    #[doc = " @note This function will transit the channel state from enable to init."]
    #[doc = ""]
    #[doc = " @param[in] chan ETM channel handle that created by `esp_etm_new_channel`"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Disable ETM channel successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Disable ETM channel failed because of invalid argument"]
    #[doc = "      - ESP_ERR_INVALID_STATE: Disable ETM channel failed because the channel is not enabled yet"]
    #[doc = "      - ESP_FAIL: Disable ETM channel failed because of other reasons"]
    pub fn esp_etm_channel_disable(chan: esp_etm_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Connect an ETM event to an ETM task via a previously allocated ETM channel"]
    #[doc = ""]
    #[doc = " @note Setting the ETM event/task handle to NULL means to disconnect the channel from any event/task"]
    #[doc = ""]
    #[doc = " @param[in] chan ETM channel handle that created by `esp_etm_new_channel`"]
    #[doc = " @param[in] event ETM event handle obtained from a driver/peripheral, e.g. `xxx_new_etm_event`"]
    #[doc = " @param[in] task ETM task handle obtained from a driver/peripheral, e.g. `xxx_new_etm_task`"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Connect ETM event and task to the channel successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Connect ETM event and task to the channel failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: Connect ETM event and task to the channel failed because of other reasons"]
    pub fn esp_etm_channel_connect(
        chan: esp_etm_channel_handle_t,
        event: esp_etm_event_handle_t,
        task: esp_etm_task_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete ETM event"]
    #[doc = ""]
    #[doc = " @note Although the ETM event comes from various peripherals, we provide the same user API to delete the event handle seamlessly."]
    #[doc = ""]
    #[doc = " @param[in] event ETM event handle obtained from a driver/peripheral, e.g. `xxx_new_etm_event`"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Delete ETM event successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Delete ETM event failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: Delete ETM event failed because of other reasons"]
    pub fn esp_etm_del_event(event: esp_etm_event_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete ETM task"]
    #[doc = ""]
    #[doc = " @note Although the ETM task comes from various peripherals, we provide the same user API to delete the task handle seamlessly."]
    #[doc = ""]
    #[doc = " @param[in] task ETM task handle obtained from a driver/peripheral, e.g. `xxx_new_etm_task`"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Delete ETM task successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Delete ETM task failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: Delete ETM task failed because of other reasons"]
    pub fn esp_etm_del_task(task: esp_etm_task_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dump ETM channel usages to the given IO stream"]
    #[doc = ""]
    #[doc = " @param[in] out_stream IO stream (e.g. stdout)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Dump ETM channel usages successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Dump ETM channel usages failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: Dump ETM channel usages failed because of other reasons"]
    pub fn esp_etm_dump(out_stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single esp_timer"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type"]
#[doc = " @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut crate::c_types::c_void)>;
#[doc = "!< Callback is called from timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = "!< Count of the methods for dispatching timer callback"]
pub const esp_timer_dispatch_t_ESP_TIMER_MAX: esp_timer_dispatch_t = 1;
#[doc = " @brief Method for dispatching timer callback"]
pub type esp_timer_dispatch_t = crate::c_types::c_uint;
#[doc = " @brief Timer configuration passed to esp_timer_create"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Function to call when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to the callback"]
    pub arg: *mut crate::c_types::c_void,
    #[doc = "!< Call the callback from task or from ISR"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump function"]
    pub name: *const crate::c_types::c_char,
    #[doc = "!< Skip unhandled events for periodic timers"]
    pub skip_unhandled_events: bool,
}
extern "C" {
    #[doc = " @brief Minimal initialization of esp_timer"]
    #[doc = ""]
    #[doc = " @note This function is called from startup code. Applications do not need"]
    #[doc = " to call this function before using other esp_timer APIs."]
    #[doc = ""]
    #[doc = " This function can be called very early in startup process, after this call"]
    #[doc = " only esp_timer_get_time function can be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn esp_timer_early_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note This function is called from startup code. Applications do not need"]
    #[doc = " to call this function before using other esp_timer APIs."]
    #[doc = " Before calling this function, esp_timer_early_init must be called by the"]
    #[doc = " startup code."]
    #[doc = ""]
    #[doc = " This function will be called from startup code on every core"]
    #[doc = " if CONFIG_ESP_TIMER_ISR_AFFINITY_NO_AFFINITY is enabled,"]
    #[doc = " It allocates the timer ISR on MULTIPLE cores and"]
    #[doc = " creates the timer task which can be run on any core."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if allocation has failed"]
    #[doc = "      - ESP_ERR_INVALID_STATE if already initialized"]
    #[doc = "      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note Normally this function should not be called from applications"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance"]
    #[doc = ""]
    #[doc = " @note When done using the timer, delete it with esp_timer_delete function."]
    #[doc = ""]
    #[doc = " @param create_args   Pointer to a structure with timer creation arguments."]
    #[doc = "                      Not saved by the library, can be allocated on the stack."]
    #[doc = " @param[out] out_handle  Output, pointer to esp_timer_handle_t variable which"]
    #[doc = "                         will hold the created timer handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if some of the create_args are not valid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet"]
    #[doc = "      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start one-shot timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param timeout_us timer timeout, in microseconds relative to the current moment"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called. This function will"]
    #[doc = " start the timer which will trigger every 'period' microseconds."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param period timer period, in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Restart a currently running timer"]
    #[doc = ""]
    #[doc = " If the given timer is a one-shot timer, the timer is restarted immediately and will timeout once in `timeout_us` microseconds."]
    #[doc = " If the given timer is a periodic timer, the timer is restarted immediately with a new period of `timeout_us` microseconds."]
    #[doc = ""]
    #[doc = " @param timer timer Handle created using esp_timer_create"]
    #[doc = " @param timeout_us Timeout, in microseconds relative to the current time."]
    #[doc = "                   In case of a periodic timer, also represents the new period."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_restart(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the timer"]
    #[doc = ""]
    #[doc = " This function stops the timer previously started using esp_timer_start_once"]
    #[doc = " or esp_timer_start_periodic."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance"]
    #[doc = ""]
    #[doc = " The timer must be stopped before deleting. A one-shot timer which has expired"]
    #[doc = " does not need to be stopped."]
    #[doc = ""]
    #[doc = " @param timer timer handle allocated using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since boot"]
    #[doc = " @return number of microseconds since underlying timer has been started"]
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp when the next timeout is expected to occur"]
    #[doc = " @return Timestamp of the nearest timer event, in microseconds."]
    #[doc = "         The timebase is the same as for the values returned by esp_timer_get_time."]
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp when the next timeout is expected to occur skipping those which have skip_unhandled_events flag"]
    #[doc = " @return Timestamp of the nearest timer event, in microseconds."]
    #[doc = "         The timebase is the same as for the values returned by esp_timer_get_time."]
    pub fn esp_timer_get_next_alarm_for_wake_up() -> i64;
}
extern "C" {
    #[doc = " @brief Get the period of a timer"]
    #[doc = ""]
    #[doc = " This function fetches the timeout period of a timer."]
    #[doc = ""]
    #[doc = " @note The timeout period is the time interval with which a timer restarts after expiry. For one-shot timers, the"]
    #[doc = " period is 0 as there is no periodicity associated with such timers."]
    #[doc = ""]
    #[doc = " @param timer timer handle allocated using esp_timer_create"]
    #[doc = " @param period memory to store the timer period value in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the arguments are invalid"]
    pub fn esp_timer_get_period(timer: esp_timer_handle_t, period: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the expiry time of a one-shot timer"]
    #[doc = ""]
    #[doc = " This function fetches the expiry time of a one-shot timer."]
    #[doc = ""]
    #[doc = " @note This API returns a valid expiry time only for a one-shot timer. It returns an error if the timer handle passed"]
    #[doc = " to the function is for a periodic timer."]
    #[doc = ""]
    #[doc = " @param timer timer handle allocated using esp_timer_create"]
    #[doc = " @param expiry memory to store the timeout value in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the arguments are invalid"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if the timer type is periodic"]
    pub fn esp_timer_get_expiry_time(timer: esp_timer_handle_t, expiry: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dump the list of timers to a stream"]
    #[doc = ""]
    #[doc = " If CONFIG_ESP_TIMER_PROFILING option is enabled, this prints the list of all"]
    #[doc = " the existing timers. Otherwise, only the list active timers is printed."]
    #[doc = ""]
    #[doc = " The format is:"]
    #[doc = ""]
    #[doc = "   name  period  alarm  times_armed  times_triggered  total_callback_run_time"]
    #[doc = ""]
    #[doc = " where:"]
    #[doc = ""]
    #[doc = " name — timer name (if CONFIG_ESP_TIMER_PROFILING is defined), or timer pointer"]
    #[doc = " period — period of timer, in microseconds, or 0 for one-shot timer"]
    #[doc = " alarm - time of the next alarm, in microseconds since boot, or 0 if the timer"]
    #[doc = "         is not started"]
    #[doc = ""]
    #[doc = " The following fields are printed if CONFIG_ESP_TIMER_PROFILING is defined:"]
    #[doc = ""]
    #[doc = " times_armed — number of times the timer was armed via esp_timer_start_X"]
    #[doc = " times_triggered - number of times the callback was called"]
    #[doc = " total_callback_run_time - total time taken by callback to execute, across all calls"]
    #[doc = ""]
    #[doc = " @param stream stream (such as stdout) to dump the information to"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if can not allocate temporary buffer for the output"]
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns status of a timer, active or not"]
    #[doc = ""]
    #[doc = " This function is used to identify if the timer is still active or not."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - 1 if timer is still active"]
    #[doc = "      - 0 if timer is not active."]
    pub fn esp_timer_is_active(timer: esp_timer_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get the ETM event handle of esp_timer underlying alarm event"]
    #[doc = ""]
    #[doc = " @note The created ETM event object can be deleted later by calling `esp_etm_del_event`"]
    #[doc = ""]
    #[doc = " @note The ETM event is generated by the underlying hardware -- systimer,"]
    #[doc = "       therefore, if the esp_timer is not clocked by systimer, then no ETM event will be generated."]
    #[doc = ""]
    #[doc = " @param[out] out_event Returned ETM event handle"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn esp_timer_new_etm_alarm_event(out_event: *mut esp_etm_event_handle_t) -> esp_err_t;
}
#[doc = "< Bluetooth is not running"]
pub const esp_bt_mode_t_ESP_BT_MODE_IDLE: esp_bt_mode_t = 0;
#[doc = "< Run BLE mode"]
pub const esp_bt_mode_t_ESP_BT_MODE_BLE: esp_bt_mode_t = 1;
#[doc = "< Run Classic BT mode"]
pub const esp_bt_mode_t_ESP_BT_MODE_CLASSIC_BT: esp_bt_mode_t = 2;
#[doc = "< Run dual mode"]
pub const esp_bt_mode_t_ESP_BT_MODE_BTDM: esp_bt_mode_t = 3;
#[doc = " @brief Bluetooth mode for controller enable/disable"]
pub type esp_bt_mode_t = crate::c_types::c_uint;
#[doc = "< HCI UART h4 transport layer"]
pub const esp_bt_ctrl_hci_tl_t_ESP_BT_CTRL_HCI_TL_UART: esp_bt_ctrl_hci_tl_t = 0;
#[doc = "< VHCI interface"]
pub const esp_bt_ctrl_hci_tl_t_ESP_BT_CTRL_HCI_TL_VHCI: esp_bt_ctrl_hci_tl_t = 1;
#[doc = " @brief Type of controller HCI transport layer"]
pub type esp_bt_ctrl_hci_tl_t = crate::c_types::c_uint;
#[doc = "< original"]
pub const esp_ble_ce_len_t_ESP_BLE_CE_LEN_TYPE_ORIG: esp_ble_ce_len_t = 0;
#[doc = "< use CE_LEN parameter from HCI commands"]
pub const esp_ble_ce_len_t_ESP_BLE_CE_LEN_TYPE_CE: esp_ble_ce_len_t = 1;
#[doc = "< Espressif vendor defined"]
pub const esp_ble_ce_len_t_ESP_BLE_CE_LEN_TYPE_SD: esp_ble_ce_len_t = 1;
#[doc = " @breif type of BLE connection event length computation"]
pub type esp_ble_ce_len_t = crate::c_types::c_uint;
#[doc = "< Bluetooth sleep mode disabled"]
pub const esp_bt_sleep_mode_t_ESP_BT_SLEEP_MODE_NONE: esp_bt_sleep_mode_t = 0;
#[doc = "< Bluetooth sleep mode 1"]
pub const esp_bt_sleep_mode_t_ESP_BT_SLEEP_MODE_1: esp_bt_sleep_mode_t = 1;
#[doc = " @brief Bluetooth sleep mode"]
pub type esp_bt_sleep_mode_t = crate::c_types::c_uint;
#[doc = "< Sleep clock not configured"]
pub const esp_bt_sleep_clock_t_ESP_BT_SLEEP_CLOCK_NONE: esp_bt_sleep_clock_t = 0;
#[doc = "< SoC main crystal"]
pub const esp_bt_sleep_clock_t_ESP_BT_SLEEP_CLOCK_MAIN_XTAL: esp_bt_sleep_clock_t = 1;
#[doc = "< External 32.768kHz crystal"]
pub const esp_bt_sleep_clock_t_ESP_BT_SLEEP_CLOCK_EXT_32K_XTAL: esp_bt_sleep_clock_t = 2;
#[doc = "< Internal 136kHz RC oscillator"]
pub const esp_bt_sleep_clock_t_ESP_BT_SLEEP_CLOCK_RTC_SLOW: esp_bt_sleep_clock_t = 3;
#[doc = "< Hardwired 32KHz clock temporarily used for FPGA"]
pub const esp_bt_sleep_clock_t_ESP_BT_SLEEP_CLOCK_FPGA_32K: esp_bt_sleep_clock_t = 4;
#[doc = " @brief Bluetooth sleep clock"]
pub type esp_bt_sleep_clock_t = crate::c_types::c_uint;
#[doc = "< anntena NO 0"]
pub const ESP_BT_ANT_IDX_0: crate::c_types::c_uint = 0;
#[doc = "< anntena NO 1"]
pub const ESP_BT_ANT_IDX_1: crate::c_types::c_uint = 1;
#[doc = " @brief antenna index used for bluetooth"]
pub type _bindgen_ty_1 = crate::c_types::c_uint;
#[doc = "< Disable the limit"]
pub const ESP_BT_COEX_PHY_CODED_TX_RX_TIME_LIMIT_FORCE_DISABLE: crate::c_types::c_uint = 0;
#[doc = "< Always Enable the limit"]
pub const ESP_BT_COEX_PHY_CODED_TX_RX_TIME_LIMIT_FORCE_ENABLE: crate::c_types::c_uint = 1;
#[doc = " @brief Maximum Tx/Rx time limit on Coded-PHY connection"]
pub type _bindgen_ty_2 = crate::c_types::c_uint;
#[doc = " @brief callback function for HCI Transport Layer send/receive operations"]
pub type esp_bt_hci_tl_callback_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut crate::c_types::c_void, status: u8)>;
#[doc = " @brief Controller HCI transport layer function structure"]
#[doc = "        This structure shall be registered when HCI transport layer is UART"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_bt_hci_tl_t {
    pub _magic: u32,
    pub _version: u32,
    pub _reserved: u32,
    pub _open: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _close: ::core::option::Option<unsafe extern "C" fn()>,
    pub _finish_transfers: ::core::option::Option<unsafe extern "C" fn()>,
    pub _recv: ::core::option::Option<
        unsafe extern "C" fn(
            buf: *mut u8,
            len: u32,
            callback: esp_bt_hci_tl_callback_t,
            arg: *mut crate::c_types::c_void,
        ),
    >,
    pub _send: ::core::option::Option<
        unsafe extern "C" fn(
            buf: *mut u8,
            len: u32,
            callback: esp_bt_hci_tl_callback_t,
            arg: *mut crate::c_types::c_void,
        ),
    >,
    pub _flow_off: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _flow_on: ::core::option::Option<unsafe extern "C" fn()>,
}
#[doc = " @brief Controller config options, depend on config mask."]
#[doc = "        Config mask indicate which functions enabled, this means"]
#[doc = "        some options or parameters of some functions enabled by config mask."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_bt_controller_config_t {
    #[doc = "< Magic number"]
    pub magic: u32,
    #[doc = "< version number of the defined structure"]
    pub version: u32,
    #[doc = "< Bluetooth controller task stack size"]
    pub controller_task_stack_size: u16,
    #[doc = "< Bluetooth controller task priority"]
    pub controller_task_prio: u8,
    #[doc = "< CPU num that Bluetooth controller task runs on"]
    pub controller_task_run_cpu: u8,
    #[doc = "< Controller mode: BR/EDR, BLE or Dual Mode"]
    pub bluetooth_mode: u8,
    #[doc = "< BLE maximum number of air activities"]
    pub ble_max_act: u8,
    #[doc = "< controller sleep mode"]
    pub sleep_mode: u8,
    #[doc = "< controller sleep clock"]
    pub sleep_clock: u8,
    #[doc = "< controller static ACL TX BUFFER number"]
    pub ble_st_acl_tx_buf_nb: u8,
    #[doc = "< controller hardware triggered CCA check"]
    pub ble_hw_cca_check: u8,
    #[doc = "< maxinum number of duplicate scan filter"]
    pub ble_adv_dup_filt_max: u16,
    #[doc = "< deprecated"]
    pub coex_param_en: bool,
    #[doc = "< connection event length computation method"]
    pub ce_len_type: u8,
    #[doc = "< deprecated"]
    pub coex_use_hooks: bool,
    #[doc = "< HCI transport layer, UART, VHCI, etc"]
    pub hci_tl_type: u8,
    #[doc = "< hci transport functions used, must be set when hci_tl_type is UART"]
    pub hci_tl_funcs: *mut esp_bt_hci_tl_t,
    #[doc = "< default Tx antenna"]
    pub txant_dft: u8,
    #[doc = "< default Rx antenna"]
    pub rxant_dft: u8,
    #[doc = "< default Tx power"]
    pub txpwr_dft: u8,
    pub cfg_mask: u32,
    #[doc = "< scan duplicate mode"]
    pub scan_duplicate_mode: u8,
    #[doc = "< scan duplicate type"]
    pub scan_duplicate_type: u8,
    #[doc = "< Normal adv size for scan duplicate"]
    pub normal_adv_size: u16,
    #[doc = "< Mesh adv size for scan duplicate"]
    pub mesh_adv_size: u16,
    #[doc = "< limit on max tx/rx time in case of connection using CODED-PHY with Wi-Fi coexistence"]
    pub coex_phy_coded_tx_rx_time_limit: u8,
    #[doc = "< hardware target"]
    pub hw_target_code: u32,
    #[doc = "< slave minimum ce length"]
    pub slave_ce_len_min: u8,
    pub hw_recorrect_en: u8,
    #[doc = "< cca threshold"]
    pub cca_thresh: u8,
    #[doc = "< scan backoff upperlimitmax value"]
    pub scan_backoff_upperlimitmax: u16,
    #[doc = "< duplicate scan list refresh time"]
    pub dup_list_refresh_period: u16,
    #[doc = "< BLE 5.0 feature support"]
    pub ble_50_feat_supp: bool,
}
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_IDLE: esp_bt_controller_status_t = 0;
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_INITED: esp_bt_controller_status_t =
    1;
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_ENABLED: esp_bt_controller_status_t =
    2;
pub const esp_bt_controller_status_t_ESP_BT_CONTROLLER_STATUS_NUM: esp_bt_controller_status_t = 3;
#[doc = " @brief Bluetooth controller enable/disable/initialised/de-initialised status"]
pub type esp_bt_controller_status_t = crate::c_types::c_uint;
#[doc = "< For connection handle 0"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL0: esp_ble_power_type_t = 0;
#[doc = "< For connection handle 1"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL1: esp_ble_power_type_t = 1;
#[doc = "< For connection handle 2"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL2: esp_ble_power_type_t = 2;
#[doc = "< For connection handle 3"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL3: esp_ble_power_type_t = 3;
#[doc = "< For connection handle 4"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL4: esp_ble_power_type_t = 4;
#[doc = "< For connection handle 5"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL5: esp_ble_power_type_t = 5;
#[doc = "< For connection handle 6"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL6: esp_ble_power_type_t = 6;
#[doc = "< For connection handle 7"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL7: esp_ble_power_type_t = 7;
#[doc = "< For connection handle 8"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_CONN_HDL8: esp_ble_power_type_t = 8;
#[doc = "< For advertising"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_ADV: esp_ble_power_type_t = 9;
#[doc = "< For scan"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_SCAN: esp_ble_power_type_t = 10;
#[doc = "< For default, if not set other, it will use default value"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_DEFAULT: esp_ble_power_type_t = 11;
#[doc = "< TYPE numbers"]
pub const esp_ble_power_type_t_ESP_BLE_PWR_TYPE_NUM: esp_ble_power_type_t = 12;
#[doc = " @brief BLE tx power type"]
#[doc = "        ESP_BLE_PWR_TYPE_CONN_HDL0-8: for each connection, and only be set after connection completed."]
#[doc = "                                      when disconnect, the correspond TX power is not effected."]
#[doc = "        ESP_BLE_PWR_TYPE_ADV : for advertising/scan response."]
#[doc = "        ESP_BLE_PWR_TYPE_SCAN : for scan."]
#[doc = "        ESP_BLE_PWR_TYPE_DEFAULT : if each connection's TX power is not set, it will use this default value."]
#[doc = "                                   if neither in scan mode nor in adv mode, it will use this default value."]
#[doc = "        If none of power type is set, system will use ESP_PWR_LVL_P3 as default for ADV/SCAN/CONN0-9."]
pub type esp_ble_power_type_t = crate::c_types::c_uint;
#[doc = "< Corresponding to -24dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N24: esp_power_level_t = 0;
#[doc = "< Corresponding to -21dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N21: esp_power_level_t = 1;
#[doc = "< Corresponding to -18dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N18: esp_power_level_t = 2;
#[doc = "< Corresponding to -15dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N15: esp_power_level_t = 3;
#[doc = "< Corresponding to -12dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N12: esp_power_level_t = 4;
#[doc = "< Corresponding to  -9dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N9: esp_power_level_t = 5;
#[doc = "< Corresponding to  -6dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N6: esp_power_level_t = 6;
#[doc = "< Corresponding to  -3dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N3: esp_power_level_t = 7;
#[doc = "< Corresponding to   0dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_N0: esp_power_level_t = 8;
#[doc = "< Corresponding to  +3dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P3: esp_power_level_t = 9;
#[doc = "< Corresponding to  +6dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P6: esp_power_level_t = 10;
#[doc = "< Corresponding to  +9dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P9: esp_power_level_t = 11;
#[doc = "< Corresponding to  +12dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P12: esp_power_level_t = 12;
#[doc = "< Corresponding to  +15dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P15: esp_power_level_t = 13;
#[doc = "< Corresponding to  +18dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P18: esp_power_level_t = 14;
#[doc = "< Corresponding to  +21dbm"]
pub const esp_power_level_t_ESP_PWR_LVL_P21: esp_power_level_t = 15;
#[doc = "< Indicates an invalid value"]
pub const esp_power_level_t_ESP_PWR_LVL_INVALID: esp_power_level_t = 255;
#[doc = " @brief Bluetooth TX power level(index), it's just a index corresponding to power(dbm)."]
pub type esp_power_level_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief  Set BLE TX power"]
    #[doc = "         Connection Tx power should only be set after connection created."]
    #[doc = " @param  power_type : The type of which tx power, could set Advertising/Connection/Default and etc"]
    #[doc = " @param  power_level: Power level(index) corresponding to absolute value(dbm)"]
    #[doc = " @return              ESP_OK - success, other - failed"]
    pub fn esp_ble_tx_power_set(
        power_type: esp_ble_power_type_t,
        power_level: esp_power_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get BLE TX power"]
    #[doc = "         Connection Tx power should only be get after connection created."]
    #[doc = " @param  power_type : The type of which tx power, could set Advertising/Connection/Default and etc"]
    #[doc = " @return             >= 0 - Power level, < 0 - Invalid"]
    pub fn esp_ble_tx_power_get(power_type: esp_ble_power_type_t) -> esp_power_level_t;
}
extern "C" {
    #[doc = " @brief       Initialize BT controller to allocate task and other resource."]
    #[doc = "              This function should be called only once, before any other BT functions are called."]
    #[doc = " @param  cfg: Initial configuration of BT controller. Different from previous version, there's a mode and some"]
    #[doc = "              connection configuration in \"cfg\" to configure controller work mode and allocate the resource which is needed."]
    #[doc = " @return      ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_init(cfg: *mut esp_bt_controller_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  De-initialize BT controller to free resource and delete task."]
    #[doc = "         You should stop advertising and scanning, as well as"]
    #[doc = "         disconnect all existing connections before de-initializing BT controller."]
    #[doc = ""]
    #[doc = " This function should be called only once, after any other BT functions are called."]
    #[doc = " This function is not whole completed, esp_bt_controller_init cannot called after this function."]
    #[doc = " @return  ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable BT controller."]
    #[doc = "               Due to a known issue, you cannot call esp_bt_controller_enable() a second time"]
    #[doc = "               to change the controller mode dynamically. To change controller mode, call"]
    #[doc = "               esp_bt_controller_disable() and then call esp_bt_controller_enable() with the new mode."]
    #[doc = " @param mode : the mode(BLE/BT/BTDM) to enable. For compatible of API, retain this argument. This mode must be"]
    #[doc = "               equal as the mode in \"cfg\" of esp_bt_controller_init()."]
    #[doc = " @return       ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_enable(mode: esp_bt_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable BT controller"]
    #[doc = " @return       ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get BT controller is initialised/de-initialised/enabled/disabled"]
    #[doc = " @return status value"]
    pub fn esp_bt_controller_get_status() -> esp_bt_controller_status_t;
}
extern "C" {
    pub fn esp_bt_get_tx_buf_num() -> u16;
}
#[doc = " @brief esp_vhci_host_callback"]
#[doc = "  used for vhci call host function to notify what host need to do"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_vhci_host_callback {
    #[doc = "< callback used to notify that the host can send packet to controller"]
    pub notify_host_send_available: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "< callback used to notify that the controller has a packet to send to the host"]
    pub notify_host_recv: ::core::option::Option<
        unsafe extern "C" fn(data: *mut u8, len: u16) -> crate::c_types::c_int,
    >,
}
#[doc = " @brief esp_vhci_host_callback"]
#[doc = "  used for vhci call host function to notify what host need to do"]
pub type esp_vhci_host_callback_t = esp_vhci_host_callback;
extern "C" {
    #[doc = " @brief esp_vhci_host_check_send_available"]
    #[doc = "  used for check actively if the host can send packet to controller or not."]
    #[doc = "  @return true for ready to send, false means cannot send packet"]
    pub fn esp_vhci_host_check_send_available() -> bool;
}
extern "C" {
    #[doc = " @brief esp_vhci_host_send_packet"]
    #[doc = " host send packet to controller"]
    #[doc = ""]
    #[doc = " Should not call this function from within a critical section"]
    #[doc = " or when the scheduler is suspended."]
    #[doc = ""]
    #[doc = " @param data the packet point"]
    #[doc = " @param len the packet length"]
    pub fn esp_vhci_host_send_packet(data: *mut u8, len: u16);
}
extern "C" {
    #[doc = " @brief esp_vhci_host_register_callback"]
    #[doc = " register the vhci reference callback"]
    #[doc = " struct defined by vhci_host_callback structure."]
    #[doc = " @param callback esp_vhci_host_callback type variable"]
    #[doc = " @return ESP_OK - success, ESP_FAIL - failed"]
    pub fn esp_vhci_host_register_callback(callback: *const esp_vhci_host_callback_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief esp_bt_controller_mem_release"]
    #[doc = " release the controller memory as per the mode"]
    #[doc = ""]
    #[doc = " This function releases the BSS, data and other sections of the controller to heap. The total size is about 70k bytes."]
    #[doc = ""]
    #[doc = " esp_bt_controller_mem_release(mode) should be called only before esp_bt_controller_init()"]
    #[doc = " or after esp_bt_controller_deinit()."]
    #[doc = ""]
    #[doc = " Note that once BT controller memory is released, the process cannot be reversed. It means you cannot use the bluetooth"]
    #[doc = " mode which you have released by this function."]
    #[doc = ""]
    #[doc = " If your firmware will later upgrade the Bluetooth controller mode (BLE -> BT Classic or disabled -> enabled)"]
    #[doc = " then do not call this function."]
    #[doc = ""]
    #[doc = " If the app calls esp_bt_controller_enable(ESP_BT_MODE_BLE) to use BLE only then it is safe to call"]
    #[doc = " esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT) at initialization time to free unused BT Classic memory."]
    #[doc = ""]
    #[doc = " If the mode is ESP_BT_MODE_BTDM, then it may be useful to call API esp_bt_mem_release(ESP_BT_MODE_BTDM) instead,"]
    #[doc = " which internally calls esp_bt_controller_mem_release(ESP_BT_MODE_BTDM) and additionally releases the BSS and data"]
    #[doc = " consumed by the BT/BLE host stack to heap. For more details about usage please refer to the documentation of"]
    #[doc = " esp_bt_mem_release() function"]
    #[doc = ""]
    #[doc = " @param mode : the mode want to release memory"]
    #[doc = " @return ESP_OK - success, other - failed"]
    pub fn esp_bt_controller_mem_release(mode: esp_bt_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief esp_bt_mem_release"]
    #[doc = " release controller memory and BSS and data section of the BT/BLE host stack as per the mode"]
    #[doc = ""]
    #[doc = " This function first releases controller memory by internally calling esp_bt_controller_mem_release()."]
    #[doc = " Additionally, if the mode is set to ESP_BT_MODE_BTDM, it also releases the BSS and data consumed by the BT/BLE host stack to heap"]
    #[doc = ""]
    #[doc = " Note that once BT memory is released, the process cannot be reversed. It means you cannot use the bluetooth"]
    #[doc = " mode which you have released by this function."]
    #[doc = ""]
    #[doc = " If your firmware will later upgrade the Bluetooth controller mode (BLE -> BT Classic or disabled -> enabled)"]
    #[doc = " then do not call this function."]
    #[doc = ""]
    #[doc = " If you never intend to use bluetooth in a current boot-up cycle, you can call esp_bt_mem_release(ESP_BT_MODE_BTDM)"]
    #[doc = " before esp_bt_controller_init or after esp_bt_controller_deinit."]
    #[doc = ""]
    #[doc = " For example, if a user only uses bluetooth for setting the WiFi configuration, and does not use bluetooth in the rest of the product operation\"."]
    #[doc = " In such cases, after receiving the WiFi configuration, you can disable/deinit bluetooth and release its memory."]
    #[doc = " Below is the sequence of APIs to be called for such scenarios:"]
    #[doc = ""]
    #[doc = "      esp_bluedroid_disable();"]
    #[doc = "      esp_bluedroid_deinit();"]
    #[doc = "      esp_bt_controller_disable();"]
    #[doc = "      esp_bt_controller_deinit();"]
    #[doc = "      esp_bt_mem_release(ESP_BT_MODE_BTDM);"]
    #[doc = ""]
    #[doc = " @param mode : the mode whose memory is to be released"]
    #[doc = " @return ESP_OK - success, other - failed"]
    pub fn esp_bt_mem_release(mode: esp_bt_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief enable bluetooth to enter modem sleep"]
    #[doc = ""]
    #[doc = " Note that this function shall not be invoked before esp_bt_controller_enable()"]
    #[doc = ""]
    #[doc = " There are currently two options for bluetooth modem sleep, one is ORIG mode, and another is EVED Mode. EVED Mode is intended for BLE only."]
    #[doc = ""]
    #[doc = " For ORIG mode:"]
    #[doc = " Bluetooth modem sleep is enabled in controller start up by default if CONFIG_BTDM_CONTROLLER_MODEM_SLEEP is set and \"ORIG mode\" is selected. In ORIG modem sleep mode, bluetooth controller will switch off some components and pause to work every now and then, if there is no event to process; and wakeup according to the scheduled interval and resume the work. It can also wakeup earlier upon external request using function \"esp_bt_controller_wakeup_request\"."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "                  - ESP_OK : success"]
    #[doc = "                  - other  : failed"]
    pub fn esp_bt_sleep_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief disable bluetooth modem sleep"]
    #[doc = ""]
    #[doc = " Note that this function shall not be invoked before esp_bt_controller_enable()"]
    #[doc = ""]
    #[doc = " If esp_bt_sleep_disable() is called, bluetooth controller will not be allowed to enter modem sleep;"]
    #[doc = ""]
    #[doc = " If ORIG modem sleep mode is in use, if this function is called, bluetooth controller may not immediately wake up if it is dormant then."]
    #[doc = " In this case, esp_bt_controller_wakeup_request() can be used to shorten the time for wakeup."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "                  - ESP_OK : success"]
    #[doc = "                  - other  : failed"]
    pub fn esp_bt_sleep_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief to check whether bluetooth controller is sleeping at the instant, if modem sleep is enabled"]
    #[doc = ""]
    #[doc = " Note that this function shall not be invoked before esp_bt_controller_enable()"]
    #[doc = " This function is supposed to be used ORIG mode of modem sleep"]
    #[doc = ""]
    #[doc = " @return  true if in modem sleep state, false otherwise"]
    pub fn esp_bt_controller_is_sleeping() -> bool;
}
extern "C" {
    #[doc = " @brief request controller to wakeup from sleeping state during sleep mode"]
    #[doc = ""]
    #[doc = " Note that this function shall not be invoked before esp_bt_controller_enable()"]
    #[doc = " Note that this function is supposed to be used ORIG mode of modem sleep"]
    #[doc = " Note that after this request, bluetooth controller may again enter sleep as long as the modem sleep is enabled"]
    #[doc = ""]
    #[doc = " Profiling shows that it takes several milliseconds to wakeup from modem sleep after this request."]
    #[doc = " Generally it takes longer if 32kHz XTAL is used than the main XTAL, due to the lower frequency of the former as the bluetooth low power clock source."]
    pub fn esp_bt_controller_wakeup_request();
}
extern "C" {
    #[doc = " @brief notify bluetooth controller task to process the event upon Tx or Rx done"]
    #[doc = ""]
    #[doc = " Note that this function shall not be invoked before esp_bt_controller_enable()"]
    #[doc = " This function can be called in both ISR and non-ISR context"]
    #[doc = ""]
    pub fn esp_bt_h4tl_eif_io_event_notify(event: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief bt Wi-Fi power domain power on"]
    pub fn esp_wifi_bt_power_domain_on();
}
extern "C" {
    #[doc = " @brief bt Wi-Fi power domain power off"]
    pub fn esp_wifi_bt_power_domain_off();
}
#[doc = "< Prefer to WiFi, WiFi will have more opportunity to use RF"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_WIFI: esp_coex_prefer_t = 0;
#[doc = "< Prefer to bluetooth, bluetooth will have more opportunity to use RF"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_BT: esp_coex_prefer_t = 1;
#[doc = "< Do balance of WiFi and bluetooth"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_BALANCE: esp_coex_prefer_t = 2;
#[doc = "< Prefer value numbers"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_NUM: esp_coex_prefer_t = 3;
#[doc = " @brief coex prefer value"]
pub type esp_coex_prefer_t = crate::c_types::c_uint;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_1: external_coex_wire_t = 0;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_2: external_coex_wire_t = 1;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_3: external_coex_wire_t = 2;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_NUM: external_coex_wire_t = 3;
pub type external_coex_wire_t = crate::c_types::c_uint;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_WIFI: esp_coex_status_type_t = 0;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_BLE: esp_coex_status_type_t = 1;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_BT: esp_coex_status_type_t = 2;
#[doc = " @brief coex status type"]
pub type esp_coex_status_type_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " @brief Get software coexist version string"]
    #[doc = ""]
    #[doc = " @return : version string"]
    pub fn esp_coex_version_get() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @deprecated Use esp_coex_status_bit_set() and esp_coex_status_bit_clear() instead."]
    #[doc = "  Set coexist preference of performance"]
    #[doc = "  For example, if prefer to bluetooth, then it will make A2DP(play audio via classic bt)"]
    #[doc = "  more smooth while wifi is runnning something."]
    #[doc = "  If prefer to wifi, it will do similar things as prefer to bluetooth."]
    #[doc = "  Default, it prefer to balance."]
    #[doc = ""]
    #[doc = "  @param prefer : the prefer enumeration value"]
    #[doc = "  @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_preference_set(prefer: esp_coex_prefer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set coex schm status"]
    #[doc = " @param type : WIFI/BLE/BT"]
    #[doc = " @param status : WIFI/BLE/BT STATUS"]
    #[doc = " @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_status_bit_set(type_: esp_coex_status_type_t, status: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear coex schm status"]
    #[doc = " @param type : WIFI/BLE/BT"]
    #[doc = " @param status : WIFI/BLE/BT STATUS"]
    #[doc = " @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_status_bit_clear(type_: esp_coex_status_type_t, status: u32) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct coex_adapter_funcs_t {
    pub _version: i32,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut crate::c_types::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void)>,
    pub _semphr_take_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            semphr: *mut crate::c_types::c_void,
            hptw: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _semphr_give_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            semphr: *mut crate::c_types::c_void,
            hptw: *mut crate::c_types::c_void,
        ) -> i32,
    >,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::c_types::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::c_types::c_void) -> i32>,
    pub _is_in_isr: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut crate::c_types::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut crate::c_types::c_void)>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _env_is_chip: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut crate::c_types::c_void)>,
    pub _timer_done:
        ::core::option::Option<unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut crate::c_types::c_void,
            pfunction: *mut crate::c_types::c_void,
            parg: *mut crate::c_types::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut crate::c_types::c_void, us: u32, repeat: bool),
    >,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_coex_adapter_funcs: coex_adapter_funcs_t;
}
pub const coex_prefer_t_COEX_PREFER_WIFI: coex_prefer_t = 0;
pub const coex_prefer_t_COEX_PREFER_BT: coex_prefer_t = 1;
pub const coex_prefer_t_COEX_PREFER_BALANCE: coex_prefer_t = 2;
pub const coex_prefer_t_COEX_PREFER_NUM: coex_prefer_t = 3;
pub type coex_prefer_t = crate::c_types::c_uint;
pub const coex_schm_callback_type_t_COEX_SCHM_CALLBACK_TYPE_WIFI: coex_schm_callback_type_t = 0;
pub const coex_schm_callback_type_t_COEX_SCHM_CALLBACK_TYPE_BT: coex_schm_callback_type_t = 1;
pub const coex_schm_callback_type_t_COEX_SCHM_CALLBACK_TYPE_I154: coex_schm_callback_type_t = 2;
pub type coex_schm_callback_type_t = crate::c_types::c_uint;
pub type coex_func_cb_t =
    ::core::option::Option<unsafe extern "C" fn(event: u32, sched_cnt: crate::c_types::c_int)>;
pub type coex_set_lpclk_source_callback_t =
    ::core::option::Option<unsafe extern "C" fn() -> esp_err_t>;
pub type coex_wifi_channel_change_cb_t =
    ::core::option::Option<unsafe extern "C" fn(primary: u8, secondary: u8)>;
extern "C" {
    #[doc = " @brief Pre-Init software coexist"]
    #[doc = "        extern function for internal use."]
    #[doc = ""]
    #[doc = " @return Init ok or failed."]
    pub fn coex_pre_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Init software coexist"]
    #[doc = "        extern function for internal use."]
    #[doc = ""]
    #[doc = " @return Init ok or failed."]
    pub fn coex_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-init software coexist"]
    #[doc = "        extern function for internal use."]
    pub fn coex_deinit();
}
extern "C" {
    #[doc = " @brief Enable software coexist"]
    #[doc = "        extern function for internal use."]
    #[doc = ""]
    #[doc = " @return Enable ok or failed."]
    pub fn coex_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable software coexist"]
    #[doc = "        extern function for internal use."]
    pub fn coex_disable();
}
extern "C" {
    #[doc = " @brief Get software coexist version string"]
    #[doc = "        extern function for internal use."]
    #[doc = " @return : version string"]
    pub fn coex_version_get() -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Coexist performance preference set from libbt.a"]
    #[doc = "        extern function for internal use."]
    #[doc = ""]
    #[doc = "  @param prefer : the prefer enumeration value"]
    #[doc = "  @return : ESP_OK - success, other - failed"]
    pub fn coex_preference_set(prefer: coex_prefer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get software coexist status."]
    #[doc = " @return : software coexist status"]
    pub fn coex_status_get() -> u32;
}
extern "C" {
    #[doc = " @brief Set software coexist condition."]
    #[doc = " @return : software coexist condition"]
    pub fn coex_condition_set(type_: u32, dissatisfy: bool);
}
extern "C" {
    #[doc = " @brief WiFi requests coexistence."]
    #[doc = ""]
    #[doc = "  @param event : WiFi event"]
    #[doc = "  @param latency : WiFi will request coexistence after latency"]
    #[doc = "  @param duration : duration for WiFi to request coexistence"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_wifi_request(event: u32, latency: u32, duration: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief WiFi release coexistence."]
    #[doc = ""]
    #[doc = "  @param event : WiFi event"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_wifi_release(event: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Set WiFi channel to coexistence module."]
    #[doc = ""]
    #[doc = "  @param primary : WiFi primary channel"]
    #[doc = "  @param secondary : WiFi secondary channel"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_wifi_channel_set(primary: u8, secondary: u8) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get WiFi channel from coexistence module."]
    #[doc = ""]
    #[doc = "  @param primary : pointer to value of WiFi primary channel"]
    #[doc = "  @param secondary : pointer to value of WiFi secondary channel"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_wifi_channel_get(primary: *mut u8, secondary: *mut u8) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register application callback function to Wi-Fi update low power clock module."]
    #[doc = ""]
    #[doc = " @param callback : Wi-Fi update low power clock callback function"]
    pub fn coex_wifi_register_update_lpclk_callback(callback: coex_set_lpclk_source_callback_t);
}
extern "C" {
    #[doc = " @brief Bluetooth requests coexistence"]
    #[doc = ""]
    #[doc = "  @param event : Bluetooth event"]
    #[doc = "  @param latency : Bluetooth will request coexistence after latency"]
    #[doc = "  @param duration : duration for Bluetooth to request coexistence"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_bt_request(event: u32, latency: u32, duration: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Bluetooth release coexistence."]
    #[doc = ""]
    #[doc = "  @param event : Bluetooth event"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_bt_release(event: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Bluetooth registers callback function to receive notification when Wi-Fi channel changes"]
    #[doc = ""]
    #[doc = "  @param callback: callback function registered to coexistence module"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_register_wifi_channel_change_callback(
        callback: coex_wifi_channel_change_cb_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Update low power clock interval"]
    pub fn coex_update_lpclk_interval();
}
extern "C" {
    #[doc = " @brief Get coexistence event duration."]
    #[doc = ""]
    #[doc = "  @param event : Coexistence event"]
    #[doc = "  @param duration: Coexistence event duration"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_event_duration_get(event: u32, duration: *mut u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get coexistence event priority."]
    #[doc = ""]
    #[doc = "  @param event : Coexistence event"]
    #[doc = "  @param pti: Coexistence event priority"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_pti_get(event: u32, pti: *mut u8) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Clear coexistence status."]
    #[doc = ""]
    #[doc = "  @param type : Coexistence status type"]
    #[doc = "  @param status: Coexistence status"]
    pub fn coex_schm_status_bit_clear(type_: u32, status: u32);
}
extern "C" {
    #[doc = " @brief Set coexistence status."]
    #[doc = ""]
    #[doc = "  @param type : Coexistence status type"]
    #[doc = "  @param status: Coexistence status"]
    pub fn coex_schm_status_bit_set(type_: u32, status: u32);
}
extern "C" {
    #[doc = " @brief Set coexistence scheme interval."]
    #[doc = ""]
    #[doc = "  @param interval : Coexistence scheme interval"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_schm_interval_set(interval: u32) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get coexistence scheme interval."]
    #[doc = ""]
    #[doc = "  @return : Coexistence scheme interval"]
    pub fn coex_schm_interval_get() -> u32;
}
extern "C" {
    #[doc = " @brief Get current coexistence scheme period."]
    #[doc = ""]
    #[doc = "  @return : Coexistence scheme period"]
    pub fn coex_schm_curr_period_get() -> u8;
}
extern "C" {
    #[doc = " @brief Get current coexistence scheme phase."]
    #[doc = ""]
    #[doc = "  @return : Coexistence scheme phase"]
    pub fn coex_schm_curr_phase_get() -> *mut crate::c_types::c_void;
}
extern "C" {
    #[doc = " @brief Set current coexistence scheme phase index."]
    #[doc = ""]
    #[doc = "  @param interval : Coexistence scheme phase index"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_schm_curr_phase_idx_set(idx: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get current coexistence scheme phase index."]
    #[doc = ""]
    #[doc = "  @return : Coexistence scheme phase index"]
    pub fn coex_schm_curr_phase_idx_get() -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register WiFi callback for coexistence starts."]
    #[doc = ""]
    #[doc = "  @param cb : WiFi callback"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_register_start_cb(
        cb: ::core::option::Option<unsafe extern "C" fn() -> crate::c_types::c_int>,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Restart current coexistence scheme."]
    #[doc = ""]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_schm_process_restart() -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register callback for coexistence scheme."]
    #[doc = ""]
    #[doc = "  @param type : callback type"]
    #[doc = "  @param callback : callback"]
    #[doc = "  @return : 0 - success, other - failed"]
    pub fn coex_schm_register_callback(
        type_: coex_schm_callback_type_t,
        callback: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Register coexistence adapter functions."]
    #[doc = ""]
    #[doc = "  @param funcs : coexistence adapter functions"]
    #[doc = "  @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_adapter_register(funcs: *mut coex_adapter_funcs_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the coexistence adapter header files in IDF and WiFi library"]
    #[doc = ""]
    #[doc = " @attention 1. It is used for internal CI version check"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK : succeed"]
    #[doc = "     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_coex_adapter_funcs_md5_check(md5: *const crate::c_types::c_char) -> esp_err_t;
}
#[doc = "< Send ESPNOW data successfully"]
pub const esp_now_send_status_t_ESP_NOW_SEND_SUCCESS: esp_now_send_status_t = 0;
#[doc = "< Send ESPNOW data fail"]
pub const esp_now_send_status_t_ESP_NOW_SEND_FAIL: esp_now_send_status_t = 1;
#[doc = " @brief Status of sending ESPNOW data ."]
pub type esp_now_send_status_t = crate::c_types::c_uint;
#[doc = " @brief ESPNOW peer information parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_peer_info {
    #[doc = "< ESPNOW peer MAC address that is also the MAC address of station or softap"]
    pub peer_addr: [u8; 6usize],
    #[doc = "< ESPNOW peer local master key that is used to encrypt data"]
    pub lmk: [u8; 16usize],
    #[doc = "< Wi-Fi channel that peer uses to send/receive ESPNOW data. If the value is 0,"]
    #[doc = "use the current channel which station or softap is on. Otherwise, it must be"]
    #[doc = "set as the channel that station or softap is on."]
    pub channel: u8,
    #[doc = "< Wi-Fi interface that peer uses to send/receive ESPNOW data"]
    pub ifidx: wifi_interface_t,
    #[doc = "< ESPNOW data that this peer sends/receives is encrypted or not"]
    pub encrypt: bool,
    #[doc = "< ESPNOW peer private data"]
    pub priv_: *mut crate::c_types::c_void,
}
#[doc = " @brief ESPNOW peer information parameters."]
pub type esp_now_peer_info_t = esp_now_peer_info;
#[doc = " @brief Number of ESPNOW peers which exist currently."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_peer_num {
    #[doc = "< Total number of ESPNOW peers, maximum value is ESP_NOW_MAX_TOTAL_PEER_NUM"]
    pub total_num: crate::c_types::c_int,
    #[doc = "< Number of encrypted ESPNOW peers, maximum value is ESP_NOW_MAX_ENCRYPT_PEER_NUM"]
    pub encrypt_num: crate::c_types::c_int,
}
#[doc = " @brief Number of ESPNOW peers which exist currently."]
pub type esp_now_peer_num_t = esp_now_peer_num;
#[doc = " @brief ESPNOW packet information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_now_recv_info {
    #[doc = "< Source address of ESPNOW packet"]
    pub src_addr: *mut u8,
    #[doc = "< Destination address of ESPNOW packet"]
    pub des_addr: *mut u8,
    #[doc = "< Rx control info of ESPNOW packet"]
    pub rx_ctrl: *mut wifi_pkt_rx_ctrl_t,
}
#[doc = " @brief ESPNOW packet information"]
pub type esp_now_recv_info_t = esp_now_recv_info;
#[doc = " @brief     Callback function of receiving ESPNOW data"]
#[doc = " @param     esp_now_info received ESPNOW packet information"]
#[doc = " @param     data received data"]
#[doc = " @param     data_len length of received data"]
#[doc = " @attention esp_now_info is a local variable，it can only be used in the callback."]
pub type esp_now_recv_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        esp_now_info: *const esp_now_recv_info_t,
        data: *const u8,
        data_len: crate::c_types::c_int,
    ),
>;
#[doc = " @brief     Callback function of sending ESPNOW data"]
#[doc = " @param     mac_addr peer MAC address"]
#[doc = " @param     status status of sending ESPNOW data (succeed or fail)"]
pub type esp_now_send_cb_t = ::core::option::Option<
    unsafe extern "C" fn(mac_addr: *const u8, status: esp_now_send_status_t),
>;
extern "C" {
    #[doc = " @brief     Initialize ESPNOW function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : Internal error"]
    pub fn esp_now_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize ESPNOW function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    pub fn esp_now_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the version of ESPNOW"]
    #[doc = ""]
    #[doc = " @param     version  ESPNOW version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_version(version: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of receiving ESPNOW data"]
    #[doc = ""]
    #[doc = " @param     cb  callback function of receiving ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_recv_cb(cb: esp_now_recv_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of receiving ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_recv_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of sending ESPNOW data"]
    #[doc = ""]
    #[doc = " @param     cb  callback function of sending ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_send_cb(cb: esp_now_send_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of sending ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_send_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send ESPNOW data"]
    #[doc = ""]
    #[doc = " @attention 1. If peer_addr is not NULL, send data to the peer whose MAC address matches peer_addr"]
    #[doc = " @attention 2. If peer_addr is NULL, send data to all of the peers that are added to the peer list"]
    #[doc = " @attention 3. The maximum length of data must be less than ESP_NOW_MAX_DATA_LEN"]
    #[doc = " @attention 4. The buffer pointed to by data argument does not need to be valid after esp_now_send returns"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = " @param     data  data to send"]
    #[doc = " @param     len  length of data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    #[doc = "          - ESP_ERR_ESPNOW_NO_MEM : out of memory, when this happens, you can delay a while before sending the next data"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    #[doc = "          - ESP_ERR_ESPNOW_IF : current WiFi interface doesn't match that of peer"]
    pub fn esp_now_send(peer_addr: *const u8, data: *const u8, len: size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Add a peer to peer list"]
    #[doc = ""]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_FULL : peer list is full"]
    #[doc = "          - ESP_ERR_ESPNOW_NO_MEM : out of memory"]
    #[doc = "          - ESP_ERR_ESPNOW_EXIST : peer has existed"]
    pub fn esp_now_add_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Delete a peer from peer list"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_del_peer(peer_addr: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Modify a peer"]
    #[doc = ""]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_FULL : peer list is full"]
    pub fn esp_now_mod_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config ESPNOW rate of specified interface"]
    #[doc = ""]
    #[doc = " @attention  1. This API should be called after esp_wifi_start()."]
    #[doc = ""]
    #[doc = " @param      ifx  Interface to be configured."]
    #[doc = " @param      rate Phy rate to be configured."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: failed"]
    pub fn esp_wifi_config_espnow_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get a peer whose MAC address matches peer_addr from peer list"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_get_peer(peer_addr: *const u8, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Fetch a peer from peer list. Only return the peer which address is unicast, for the multicast/broadcast address, the function will ignore and try to find the next in the peer list."]
    #[doc = ""]
    #[doc = " @param     from_head  fetch from head of list or not"]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_fetch_peer(from_head: bool, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Peer exists or not"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - true : peer exists"]
    #[doc = "          - false : peer not exists"]
    pub fn esp_now_is_peer_exist(peer_addr: *const u8) -> bool;
}
extern "C" {
    #[doc = " @brief     Get the number of peers"]
    #[doc = ""]
    #[doc = " @param     num  number of peers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_peer_num(num: *mut esp_now_peer_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the primary master key"]
    #[doc = ""]
    #[doc = " @param     pmk  primary master key"]
    #[doc = ""]
    #[doc = " @attention 1. primary master key is used to encrypt local master key"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_set_pmk(pmk: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set wake window for esp_now to wake up in interval unit"]
    #[doc = ""]
    #[doc = " @param     window  Milliseconds would the chip keep waked each interval, from 0 to 65535."]
    #[doc = ""]
    #[doc = " @attention 1. This configuration could work at connected status."]
    #[doc = "               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status."]
    #[doc = " @attention 2. Default value is the maximum."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_set_wake_window(window: u16) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_adpt {
    pub _address: u8,
}
pub type __builtin_va_list = *mut crate::c_types::c_void;

unsafe impl Sync for wifi_init_config_t {}
unsafe impl Sync for wifi_osi_funcs_t {}
